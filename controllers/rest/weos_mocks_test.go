// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package rest_test

import (
	"context"
	"database/sql"
	context2 "github.com/wepala/weos-service/context"
	weos "github.com/wepala/weos-service/model"
	"gorm.io/gorm"
	"net/http"
	"sync"
)

// Ensure, that EventRepositoryMock does implement weos.EventRepository.
// If this is not the case, regenerate this file with moq.
var _ weos.EventRepository = &EventRepositoryMock{}

// EventRepositoryMock is a mock implementation of weos.EventRepository.
//
//     func TestSomethingThatUsesEventRepository(t *testing.T) {
//
//         // make and configure a mocked weos.EventRepository
//         mockedEventRepository := &EventRepositoryMock{
//             AddSubscriberFunc: func(handler weos.EventHandler)  {
// 	               panic("mock out the AddSubscriber method")
//             },
//             FlushFunc: func() error {
// 	               panic("mock out the Flush method")
//             },
//             GetAggregateSequenceNumberFunc: func(ID string) (int64, error) {
// 	               panic("mock out the GetAggregateSequenceNumber method")
//             },
//             GetByAggregateFunc: func(ID string) ([]*weos.Event, error) {
// 	               panic("mock out the GetByAggregate method")
//             },
//             GetByAggregateAndSequenceRangeFunc: func(ID string, start int64, end int64) ([]*weos.Event, error) {
// 	               panic("mock out the GetByAggregateAndSequenceRange method")
//             },
//             GetByAggregateAndTypeFunc: func(ID string, entityType string) ([]*weos.Event, error) {
// 	               panic("mock out the GetByAggregateAndType method")
//             },
//             GetByEntityAndAggregateFunc: func(entityID string, entityType string, rootID string) ([]*weos.Event, error) {
// 	               panic("mock out the GetByEntityAndAggregate method")
//             },
//             GetSubscribersFunc: func() ([]weos.EventHandler, error) {
// 	               panic("mock out the GetSubscribers method")
//             },
//             MigrateFunc: func(ctx context.Context) error {
// 	               panic("mock out the Migrate method")
//             },
//             PersistFunc: func(ctxt context.Context, entity weos.AggregateInterface) error {
// 	               panic("mock out the Persist method")
//             },
//         }
//
//         // use mockedEventRepository in code that requires weos.EventRepository
//         // and then make assertions.
//
//     }
type EventRepositoryMock struct {
	// AddSubscriberFunc mocks the AddSubscriber method.
	AddSubscriberFunc func(handler weos.EventHandler)

	// FlushFunc mocks the Flush method.
	FlushFunc func() error

	// GetAggregateSequenceNumberFunc mocks the GetAggregateSequenceNumber method.
	GetAggregateSequenceNumberFunc func(ID string) (int64, error)

	// GetByAggregateFunc mocks the GetByAggregate method.
	GetByAggregateFunc func(ID string) ([]*weos.Event, error)

	// GetByAggregateAndSequenceRangeFunc mocks the GetByAggregateAndSequenceRange method.
	GetByAggregateAndSequenceRangeFunc func(ID string, start int64, end int64) ([]*weos.Event, error)

	// GetByAggregateAndTypeFunc mocks the GetByAggregateAndType method.
	GetByAggregateAndTypeFunc func(ID string, entityType string) ([]*weos.Event, error)

	// GetByEntityAndAggregateFunc mocks the GetByEntityAndAggregate method.
	GetByEntityAndAggregateFunc func(entityID string, entityType string, rootID string) ([]*weos.Event, error)

	// GetSubscribersFunc mocks the GetSubscribers method.
	GetSubscribersFunc func() ([]weos.EventHandler, error)

	// MigrateFunc mocks the Migrate method.
	MigrateFunc func(ctx context.Context) error

	// PersistFunc mocks the Persist method.
	PersistFunc func(ctxt context.Context, entity weos.AggregateInterface) error

	// calls tracks calls to the methods.
	calls struct {
		// AddSubscriber holds details about calls to the AddSubscriber method.
		AddSubscriber []struct {
			// Handler is the handler argument value.
			Handler weos.EventHandler
		}
		// Flush holds details about calls to the Flush method.
		Flush []struct {
		}
		// GetAggregateSequenceNumber holds details about calls to the GetAggregateSequenceNumber method.
		GetAggregateSequenceNumber []struct {
			// ID is the ID argument value.
			ID string
		}
		// GetByAggregate holds details about calls to the GetByAggregate method.
		GetByAggregate []struct {
			// ID is the ID argument value.
			ID string
		}
		// GetByAggregateAndSequenceRange holds details about calls to the GetByAggregateAndSequenceRange method.
		GetByAggregateAndSequenceRange []struct {
			// ID is the ID argument value.
			ID string
			// Start is the start argument value.
			Start int64
			// End is the end argument value.
			End int64
		}
		// GetByAggregateAndType holds details about calls to the GetByAggregateAndType method.
		GetByAggregateAndType []struct {
			// ID is the ID argument value.
			ID string
			// EntityType is the entityType argument value.
			EntityType string
		}
		// GetByEntityAndAggregate holds details about calls to the GetByEntityAndAggregate method.
		GetByEntityAndAggregate []struct {
			// EntityID is the entityID argument value.
			EntityID string
			// EntityType is the entityType argument value.
			EntityType string
			// RootID is the rootID argument value.
			RootID string
		}
		// GetSubscribers holds details about calls to the GetSubscribers method.
		GetSubscribers []struct {
		}
		// Migrate holds details about calls to the Migrate method.
		Migrate []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// Persist holds details about calls to the Persist method.
		Persist []struct {
			// Ctxt is the ctxt argument value.
			Ctxt context.Context
			// Entity is the entity argument value.
			Entity weos.AggregateInterface
		}
	}
	lockAddSubscriber                  sync.RWMutex
	lockFlush                          sync.RWMutex
	lockGetAggregateSequenceNumber     sync.RWMutex
	lockGetByAggregate                 sync.RWMutex
	lockGetByAggregateAndSequenceRange sync.RWMutex
	lockGetByAggregateAndType          sync.RWMutex
	lockGetByEntityAndAggregate        sync.RWMutex
	lockGetSubscribers                 sync.RWMutex
	lockMigrate                        sync.RWMutex
	lockPersist                        sync.RWMutex
}

// AddSubscriber calls AddSubscriberFunc.
func (mock *EventRepositoryMock) AddSubscriber(handler weos.EventHandler) {
	if mock.AddSubscriberFunc == nil {
		panic("EventRepositoryMock.AddSubscriberFunc: method is nil but EventRepository.AddSubscriber was just called")
	}
	callInfo := struct {
		Handler weos.EventHandler
	}{
		Handler: handler,
	}
	mock.lockAddSubscriber.Lock()
	mock.calls.AddSubscriber = append(mock.calls.AddSubscriber, callInfo)
	mock.lockAddSubscriber.Unlock()
	mock.AddSubscriberFunc(handler)
}

// AddSubscriberCalls gets all the calls that were made to AddSubscriber.
// Check the length with:
//     len(mockedEventRepository.AddSubscriberCalls())
func (mock *EventRepositoryMock) AddSubscriberCalls() []struct {
	Handler weos.EventHandler
} {
	var calls []struct {
		Handler weos.EventHandler
	}
	mock.lockAddSubscriber.RLock()
	calls = mock.calls.AddSubscriber
	mock.lockAddSubscriber.RUnlock()
	return calls
}

// Flush calls FlushFunc.
func (mock *EventRepositoryMock) Flush() error {
	if mock.FlushFunc == nil {
		panic("EventRepositoryMock.FlushFunc: method is nil but EventRepository.Flush was just called")
	}
	callInfo := struct {
	}{}
	mock.lockFlush.Lock()
	mock.calls.Flush = append(mock.calls.Flush, callInfo)
	mock.lockFlush.Unlock()
	return mock.FlushFunc()
}

// FlushCalls gets all the calls that were made to Flush.
// Check the length with:
//     len(mockedEventRepository.FlushCalls())
func (mock *EventRepositoryMock) FlushCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockFlush.RLock()
	calls = mock.calls.Flush
	mock.lockFlush.RUnlock()
	return calls
}

// GetAggregateSequenceNumber calls GetAggregateSequenceNumberFunc.
func (mock *EventRepositoryMock) GetAggregateSequenceNumber(ID string) (int64, error) {
	if mock.GetAggregateSequenceNumberFunc == nil {
		panic("EventRepositoryMock.GetAggregateSequenceNumberFunc: method is nil but EventRepository.GetAggregateSequenceNumber was just called")
	}
	callInfo := struct {
		ID string
	}{
		ID: ID,
	}
	mock.lockGetAggregateSequenceNumber.Lock()
	mock.calls.GetAggregateSequenceNumber = append(mock.calls.GetAggregateSequenceNumber, callInfo)
	mock.lockGetAggregateSequenceNumber.Unlock()
	return mock.GetAggregateSequenceNumberFunc(ID)
}

// GetAggregateSequenceNumberCalls gets all the calls that were made to GetAggregateSequenceNumber.
// Check the length with:
//     len(mockedEventRepository.GetAggregateSequenceNumberCalls())
func (mock *EventRepositoryMock) GetAggregateSequenceNumberCalls() []struct {
	ID string
} {
	var calls []struct {
		ID string
	}
	mock.lockGetAggregateSequenceNumber.RLock()
	calls = mock.calls.GetAggregateSequenceNumber
	mock.lockGetAggregateSequenceNumber.RUnlock()
	return calls
}

// GetByAggregate calls GetByAggregateFunc.
func (mock *EventRepositoryMock) GetByAggregate(ID string) ([]*weos.Event, error) {
	if mock.GetByAggregateFunc == nil {
		panic("EventRepositoryMock.GetByAggregateFunc: method is nil but EventRepository.GetByAggregate was just called")
	}
	callInfo := struct {
		ID string
	}{
		ID: ID,
	}
	mock.lockGetByAggregate.Lock()
	mock.calls.GetByAggregate = append(mock.calls.GetByAggregate, callInfo)
	mock.lockGetByAggregate.Unlock()
	return mock.GetByAggregateFunc(ID)
}

// GetByAggregateCalls gets all the calls that were made to GetByAggregate.
// Check the length with:
//     len(mockedEventRepository.GetByAggregateCalls())
func (mock *EventRepositoryMock) GetByAggregateCalls() []struct {
	ID string
} {
	var calls []struct {
		ID string
	}
	mock.lockGetByAggregate.RLock()
	calls = mock.calls.GetByAggregate
	mock.lockGetByAggregate.RUnlock()
	return calls
}

// GetByAggregateAndSequenceRange calls GetByAggregateAndSequenceRangeFunc.
func (mock *EventRepositoryMock) GetByAggregateAndSequenceRange(ID string, start int64, end int64) ([]*weos.Event, error) {
	if mock.GetByAggregateAndSequenceRangeFunc == nil {
		panic("EventRepositoryMock.GetByAggregateAndSequenceRangeFunc: method is nil but EventRepository.GetByAggregateAndSequenceRange was just called")
	}
	callInfo := struct {
		ID    string
		Start int64
		End   int64
	}{
		ID:    ID,
		Start: start,
		End:   end,
	}
	mock.lockGetByAggregateAndSequenceRange.Lock()
	mock.calls.GetByAggregateAndSequenceRange = append(mock.calls.GetByAggregateAndSequenceRange, callInfo)
	mock.lockGetByAggregateAndSequenceRange.Unlock()
	return mock.GetByAggregateAndSequenceRangeFunc(ID, start, end)
}

// GetByAggregateAndSequenceRangeCalls gets all the calls that were made to GetByAggregateAndSequenceRange.
// Check the length with:
//     len(mockedEventRepository.GetByAggregateAndSequenceRangeCalls())
func (mock *EventRepositoryMock) GetByAggregateAndSequenceRangeCalls() []struct {
	ID    string
	Start int64
	End   int64
} {
	var calls []struct {
		ID    string
		Start int64
		End   int64
	}
	mock.lockGetByAggregateAndSequenceRange.RLock()
	calls = mock.calls.GetByAggregateAndSequenceRange
	mock.lockGetByAggregateAndSequenceRange.RUnlock()
	return calls
}

// GetByAggregateAndType calls GetByAggregateAndTypeFunc.
func (mock *EventRepositoryMock) GetByAggregateAndType(ID string, entityType string) ([]*weos.Event, error) {
	if mock.GetByAggregateAndTypeFunc == nil {
		panic("EventRepositoryMock.GetByAggregateAndTypeFunc: method is nil but EventRepository.GetByAggregateAndType was just called")
	}
	callInfo := struct {
		ID         string
		EntityType string
	}{
		ID:         ID,
		EntityType: entityType,
	}
	mock.lockGetByAggregateAndType.Lock()
	mock.calls.GetByAggregateAndType = append(mock.calls.GetByAggregateAndType, callInfo)
	mock.lockGetByAggregateAndType.Unlock()
	return mock.GetByAggregateAndTypeFunc(ID, entityType)
}

// GetByAggregateAndTypeCalls gets all the calls that were made to GetByAggregateAndType.
// Check the length with:
//     len(mockedEventRepository.GetByAggregateAndTypeCalls())
func (mock *EventRepositoryMock) GetByAggregateAndTypeCalls() []struct {
	ID         string
	EntityType string
} {
	var calls []struct {
		ID         string
		EntityType string
	}
	mock.lockGetByAggregateAndType.RLock()
	calls = mock.calls.GetByAggregateAndType
	mock.lockGetByAggregateAndType.RUnlock()
	return calls
}

// GetByEntityAndAggregate calls GetByEntityAndAggregateFunc.
func (mock *EventRepositoryMock) GetByEntityAndAggregate(entityID string, entityType string, rootID string) ([]*weos.Event, error) {
	if mock.GetByEntityAndAggregateFunc == nil {
		panic("EventRepositoryMock.GetByEntityAndAggregateFunc: method is nil but EventRepository.GetByEntityAndAggregate was just called")
	}
	callInfo := struct {
		EntityID   string
		EntityType string
		RootID     string
	}{
		EntityID:   entityID,
		EntityType: entityType,
		RootID:     rootID,
	}
	mock.lockGetByEntityAndAggregate.Lock()
	mock.calls.GetByEntityAndAggregate = append(mock.calls.GetByEntityAndAggregate, callInfo)
	mock.lockGetByEntityAndAggregate.Unlock()
	return mock.GetByEntityAndAggregateFunc(entityID, entityType, rootID)
}

// GetByEntityAndAggregateCalls gets all the calls that were made to GetByEntityAndAggregate.
// Check the length with:
//     len(mockedEventRepository.GetByEntityAndAggregateCalls())
func (mock *EventRepositoryMock) GetByEntityAndAggregateCalls() []struct {
	EntityID   string
	EntityType string
	RootID     string
} {
	var calls []struct {
		EntityID   string
		EntityType string
		RootID     string
	}
	mock.lockGetByEntityAndAggregate.RLock()
	calls = mock.calls.GetByEntityAndAggregate
	mock.lockGetByEntityAndAggregate.RUnlock()
	return calls
}

// GetSubscribers calls GetSubscribersFunc.
func (mock *EventRepositoryMock) GetSubscribers() ([]weos.EventHandler, error) {
	if mock.GetSubscribersFunc == nil {
		panic("EventRepositoryMock.GetSubscribersFunc: method is nil but EventRepository.GetSubscribers was just called")
	}
	callInfo := struct {
	}{}
	mock.lockGetSubscribers.Lock()
	mock.calls.GetSubscribers = append(mock.calls.GetSubscribers, callInfo)
	mock.lockGetSubscribers.Unlock()
	return mock.GetSubscribersFunc()
}

// GetSubscribersCalls gets all the calls that were made to GetSubscribers.
// Check the length with:
//     len(mockedEventRepository.GetSubscribersCalls())
func (mock *EventRepositoryMock) GetSubscribersCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockGetSubscribers.RLock()
	calls = mock.calls.GetSubscribers
	mock.lockGetSubscribers.RUnlock()
	return calls
}

// Migrate calls MigrateFunc.
func (mock *EventRepositoryMock) Migrate(ctx context.Context) error {
	if mock.MigrateFunc == nil {
		panic("EventRepositoryMock.MigrateFunc: method is nil but EventRepository.Migrate was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockMigrate.Lock()
	mock.calls.Migrate = append(mock.calls.Migrate, callInfo)
	mock.lockMigrate.Unlock()
	return mock.MigrateFunc(ctx)
}

// MigrateCalls gets all the calls that were made to Migrate.
// Check the length with:
//     len(mockedEventRepository.MigrateCalls())
func (mock *EventRepositoryMock) MigrateCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockMigrate.RLock()
	calls = mock.calls.Migrate
	mock.lockMigrate.RUnlock()
	return calls
}

// Persist calls PersistFunc.
func (mock *EventRepositoryMock) Persist(ctxt context.Context, entity weos.AggregateInterface) error {
	if mock.PersistFunc == nil {
		panic("EventRepositoryMock.PersistFunc: method is nil but EventRepository.Persist was just called")
	}
	callInfo := struct {
		Ctxt   context.Context
		Entity weos.AggregateInterface
	}{
		Ctxt:   ctxt,
		Entity: entity,
	}
	mock.lockPersist.Lock()
	mock.calls.Persist = append(mock.calls.Persist, callInfo)
	mock.lockPersist.Unlock()
	return mock.PersistFunc(ctxt, entity)
}

// PersistCalls gets all the calls that were made to Persist.
// Check the length with:
//     len(mockedEventRepository.PersistCalls())
func (mock *EventRepositoryMock) PersistCalls() []struct {
	Ctxt   context.Context
	Entity weos.AggregateInterface
} {
	var calls []struct {
		Ctxt   context.Context
		Entity weos.AggregateInterface
	}
	mock.lockPersist.RLock()
	calls = mock.calls.Persist
	mock.lockPersist.RUnlock()
	return calls
}

// Ensure, that LogMock does implement weos.Log.
// If this is not the case, regenerate this file with moq.
var _ weos.Log = &LogMock{}

// LogMock is a mock implementation of weos.Log.
//
//     func TestSomethingThatUsesLog(t *testing.T) {
//
//         // make and configure a mocked weos.Log
//         mockedLog := &LogMock{
//             DebugFunc: func(args ...interface{})  {
// 	               panic("mock out the Debug method")
//             },
//             DebugfFunc: func(format string, args ...interface{})  {
// 	               panic("mock out the Debugf method")
//             },
//             ErrorFunc: func(args ...interface{})  {
// 	               panic("mock out the Error method")
//             },
//             ErrorfFunc: func(format string, args ...interface{})  {
// 	               panic("mock out the Errorf method")
//             },
//             FatalFunc: func(args ...interface{})  {
// 	               panic("mock out the Fatal method")
//             },
//             FatalfFunc: func(format string, args ...interface{})  {
// 	               panic("mock out the Fatalf method")
//             },
//             InfoFunc: func(args ...interface{})  {
// 	               panic("mock out the Info method")
//             },
//             InfofFunc: func(format string, args ...interface{})  {
// 	               panic("mock out the Infof method")
//             },
//             PanicFunc: func(args ...interface{})  {
// 	               panic("mock out the Panic method")
//             },
//             PanicfFunc: func(format string, args ...interface{})  {
// 	               panic("mock out the Panicf method")
//             },
//             PrintFunc: func(args ...interface{})  {
// 	               panic("mock out the Print method")
//             },
//             PrintfFunc: func(format string, args ...interface{})  {
// 	               panic("mock out the Printf method")
//             },
//         }
//
//         // use mockedLog in code that requires weos.Log
//         // and then make assertions.
//
//     }
type LogMock struct {
	// DebugFunc mocks the Debug method.
	DebugFunc func(args ...interface{})

	// DebugfFunc mocks the Debugf method.
	DebugfFunc func(format string, args ...interface{})

	// ErrorFunc mocks the Error method.
	ErrorFunc func(args ...interface{})

	// ErrorfFunc mocks the Errorf method.
	ErrorfFunc func(format string, args ...interface{})

	// FatalFunc mocks the Fatal method.
	FatalFunc func(args ...interface{})

	// FatalfFunc mocks the Fatalf method.
	FatalfFunc func(format string, args ...interface{})

	// InfoFunc mocks the Info method.
	InfoFunc func(args ...interface{})

	// InfofFunc mocks the Infof method.
	InfofFunc func(format string, args ...interface{})

	// PanicFunc mocks the Panic method.
	PanicFunc func(args ...interface{})

	// PanicfFunc mocks the Panicf method.
	PanicfFunc func(format string, args ...interface{})

	// PrintFunc mocks the Print method.
	PrintFunc func(args ...interface{})

	// PrintfFunc mocks the Printf method.
	PrintfFunc func(format string, args ...interface{})

	// calls tracks calls to the methods.
	calls struct {
		// Debug holds details about calls to the Debug method.
		Debug []struct {
			// Args is the args argument value.
			Args []interface{}
		}
		// Debugf holds details about calls to the Debugf method.
		Debugf []struct {
			// Format is the format argument value.
			Format string
			// Args is the args argument value.
			Args []interface{}
		}
		// Error holds details about calls to the Error method.
		Error []struct {
			// Args is the args argument value.
			Args []interface{}
		}
		// Errorf holds details about calls to the Errorf method.
		Errorf []struct {
			// Format is the format argument value.
			Format string
			// Args is the args argument value.
			Args []interface{}
		}
		// Fatal holds details about calls to the Fatal method.
		Fatal []struct {
			// Args is the args argument value.
			Args []interface{}
		}
		// Fatalf holds details about calls to the Fatalf method.
		Fatalf []struct {
			// Format is the format argument value.
			Format string
			// Args is the args argument value.
			Args []interface{}
		}
		// Info holds details about calls to the Info method.
		Info []struct {
			// Args is the args argument value.
			Args []interface{}
		}
		// Infof holds details about calls to the Infof method.
		Infof []struct {
			// Format is the format argument value.
			Format string
			// Args is the args argument value.
			Args []interface{}
		}
		// Panic holds details about calls to the Panic method.
		Panic []struct {
			// Args is the args argument value.
			Args []interface{}
		}
		// Panicf holds details about calls to the Panicf method.
		Panicf []struct {
			// Format is the format argument value.
			Format string
			// Args is the args argument value.
			Args []interface{}
		}
		// Print holds details about calls to the Print method.
		Print []struct {
			// Args is the args argument value.
			Args []interface{}
		}
		// Printf holds details about calls to the Printf method.
		Printf []struct {
			// Format is the format argument value.
			Format string
			// Args is the args argument value.
			Args []interface{}
		}
	}
	lockDebug  sync.RWMutex
	lockDebugf sync.RWMutex
	lockError  sync.RWMutex
	lockErrorf sync.RWMutex
	lockFatal  sync.RWMutex
	lockFatalf sync.RWMutex
	lockInfo   sync.RWMutex
	lockInfof  sync.RWMutex
	lockPanic  sync.RWMutex
	lockPanicf sync.RWMutex
	lockPrint  sync.RWMutex
	lockPrintf sync.RWMutex
}

// Debug calls DebugFunc.
func (mock *LogMock) Debug(args ...interface{}) {
	if mock.DebugFunc == nil {
		panic("LogMock.DebugFunc: method is nil but Log.Debug was just called")
	}
	callInfo := struct {
		Args []interface{}
	}{
		Args: args,
	}
	mock.lockDebug.Lock()
	mock.calls.Debug = append(mock.calls.Debug, callInfo)
	mock.lockDebug.Unlock()
	mock.DebugFunc(args...)
}

// DebugCalls gets all the calls that were made to Debug.
// Check the length with:
//     len(mockedLog.DebugCalls())
func (mock *LogMock) DebugCalls() []struct {
	Args []interface{}
} {
	var calls []struct {
		Args []interface{}
	}
	mock.lockDebug.RLock()
	calls = mock.calls.Debug
	mock.lockDebug.RUnlock()
	return calls
}

// Debugf calls DebugfFunc.
func (mock *LogMock) Debugf(format string, args ...interface{}) {
	if mock.DebugfFunc == nil {
		panic("LogMock.DebugfFunc: method is nil but Log.Debugf was just called")
	}
	callInfo := struct {
		Format string
		Args   []interface{}
	}{
		Format: format,
		Args:   args,
	}
	mock.lockDebugf.Lock()
	mock.calls.Debugf = append(mock.calls.Debugf, callInfo)
	mock.lockDebugf.Unlock()
	mock.DebugfFunc(format, args...)
}

// DebugfCalls gets all the calls that were made to Debugf.
// Check the length with:
//     len(mockedLog.DebugfCalls())
func (mock *LogMock) DebugfCalls() []struct {
	Format string
	Args   []interface{}
} {
	var calls []struct {
		Format string
		Args   []interface{}
	}
	mock.lockDebugf.RLock()
	calls = mock.calls.Debugf
	mock.lockDebugf.RUnlock()
	return calls
}

// Error calls ErrorFunc.
func (mock *LogMock) Error(args ...interface{}) {
	if mock.ErrorFunc == nil {
		panic("LogMock.ErrorFunc: method is nil but Log.Error was just called")
	}
	callInfo := struct {
		Args []interface{}
	}{
		Args: args,
	}
	mock.lockError.Lock()
	mock.calls.Error = append(mock.calls.Error, callInfo)
	mock.lockError.Unlock()
	mock.ErrorFunc(args...)
}

// ErrorCalls gets all the calls that were made to Error.
// Check the length with:
//     len(mockedLog.ErrorCalls())
func (mock *LogMock) ErrorCalls() []struct {
	Args []interface{}
} {
	var calls []struct {
		Args []interface{}
	}
	mock.lockError.RLock()
	calls = mock.calls.Error
	mock.lockError.RUnlock()
	return calls
}

// Errorf calls ErrorfFunc.
func (mock *LogMock) Errorf(format string, args ...interface{}) {
	if mock.ErrorfFunc == nil {
		panic("LogMock.ErrorfFunc: method is nil but Log.Errorf was just called")
	}
	callInfo := struct {
		Format string
		Args   []interface{}
	}{
		Format: format,
		Args:   args,
	}
	mock.lockErrorf.Lock()
	mock.calls.Errorf = append(mock.calls.Errorf, callInfo)
	mock.lockErrorf.Unlock()
	mock.ErrorfFunc(format, args...)
}

// ErrorfCalls gets all the calls that were made to Errorf.
// Check the length with:
//     len(mockedLog.ErrorfCalls())
func (mock *LogMock) ErrorfCalls() []struct {
	Format string
	Args   []interface{}
} {
	var calls []struct {
		Format string
		Args   []interface{}
	}
	mock.lockErrorf.RLock()
	calls = mock.calls.Errorf
	mock.lockErrorf.RUnlock()
	return calls
}

// Fatal calls FatalFunc.
func (mock *LogMock) Fatal(args ...interface{}) {
	if mock.FatalFunc == nil {
		panic("LogMock.FatalFunc: method is nil but Log.Fatal was just called")
	}
	callInfo := struct {
		Args []interface{}
	}{
		Args: args,
	}
	mock.lockFatal.Lock()
	mock.calls.Fatal = append(mock.calls.Fatal, callInfo)
	mock.lockFatal.Unlock()
	mock.FatalFunc(args...)
}

// FatalCalls gets all the calls that were made to Fatal.
// Check the length with:
//     len(mockedLog.FatalCalls())
func (mock *LogMock) FatalCalls() []struct {
	Args []interface{}
} {
	var calls []struct {
		Args []interface{}
	}
	mock.lockFatal.RLock()
	calls = mock.calls.Fatal
	mock.lockFatal.RUnlock()
	return calls
}

// Fatalf calls FatalfFunc.
func (mock *LogMock) Fatalf(format string, args ...interface{}) {
	if mock.FatalfFunc == nil {
		panic("LogMock.FatalfFunc: method is nil but Log.Fatalf was just called")
	}
	callInfo := struct {
		Format string
		Args   []interface{}
	}{
		Format: format,
		Args:   args,
	}
	mock.lockFatalf.Lock()
	mock.calls.Fatalf = append(mock.calls.Fatalf, callInfo)
	mock.lockFatalf.Unlock()
	mock.FatalfFunc(format, args...)
}

// FatalfCalls gets all the calls that were made to Fatalf.
// Check the length with:
//     len(mockedLog.FatalfCalls())
func (mock *LogMock) FatalfCalls() []struct {
	Format string
	Args   []interface{}
} {
	var calls []struct {
		Format string
		Args   []interface{}
	}
	mock.lockFatalf.RLock()
	calls = mock.calls.Fatalf
	mock.lockFatalf.RUnlock()
	return calls
}

// Info calls InfoFunc.
func (mock *LogMock) Info(args ...interface{}) {
	if mock.InfoFunc == nil {
		panic("LogMock.InfoFunc: method is nil but Log.Info was just called")
	}
	callInfo := struct {
		Args []interface{}
	}{
		Args: args,
	}
	mock.lockInfo.Lock()
	mock.calls.Info = append(mock.calls.Info, callInfo)
	mock.lockInfo.Unlock()
	mock.InfoFunc(args...)
}

// InfoCalls gets all the calls that were made to Info.
// Check the length with:
//     len(mockedLog.InfoCalls())
func (mock *LogMock) InfoCalls() []struct {
	Args []interface{}
} {
	var calls []struct {
		Args []interface{}
	}
	mock.lockInfo.RLock()
	calls = mock.calls.Info
	mock.lockInfo.RUnlock()
	return calls
}

// Infof calls InfofFunc.
func (mock *LogMock) Infof(format string, args ...interface{}) {
	if mock.InfofFunc == nil {
		panic("LogMock.InfofFunc: method is nil but Log.Infof was just called")
	}
	callInfo := struct {
		Format string
		Args   []interface{}
	}{
		Format: format,
		Args:   args,
	}
	mock.lockInfof.Lock()
	mock.calls.Infof = append(mock.calls.Infof, callInfo)
	mock.lockInfof.Unlock()
	mock.InfofFunc(format, args...)
}

// InfofCalls gets all the calls that were made to Infof.
// Check the length with:
//     len(mockedLog.InfofCalls())
func (mock *LogMock) InfofCalls() []struct {
	Format string
	Args   []interface{}
} {
	var calls []struct {
		Format string
		Args   []interface{}
	}
	mock.lockInfof.RLock()
	calls = mock.calls.Infof
	mock.lockInfof.RUnlock()
	return calls
}

// Panic calls PanicFunc.
func (mock *LogMock) Panic(args ...interface{}) {
	if mock.PanicFunc == nil {
		panic("LogMock.PanicFunc: method is nil but Log.Panic was just called")
	}
	callInfo := struct {
		Args []interface{}
	}{
		Args: args,
	}
	mock.lockPanic.Lock()
	mock.calls.Panic = append(mock.calls.Panic, callInfo)
	mock.lockPanic.Unlock()
	mock.PanicFunc(args...)
}

// PanicCalls gets all the calls that were made to Panic.
// Check the length with:
//     len(mockedLog.PanicCalls())
func (mock *LogMock) PanicCalls() []struct {
	Args []interface{}
} {
	var calls []struct {
		Args []interface{}
	}
	mock.lockPanic.RLock()
	calls = mock.calls.Panic
	mock.lockPanic.RUnlock()
	return calls
}

// Panicf calls PanicfFunc.
func (mock *LogMock) Panicf(format string, args ...interface{}) {
	if mock.PanicfFunc == nil {
		panic("LogMock.PanicfFunc: method is nil but Log.Panicf was just called")
	}
	callInfo := struct {
		Format string
		Args   []interface{}
	}{
		Format: format,
		Args:   args,
	}
	mock.lockPanicf.Lock()
	mock.calls.Panicf = append(mock.calls.Panicf, callInfo)
	mock.lockPanicf.Unlock()
	mock.PanicfFunc(format, args...)
}

// PanicfCalls gets all the calls that were made to Panicf.
// Check the length with:
//     len(mockedLog.PanicfCalls())
func (mock *LogMock) PanicfCalls() []struct {
	Format string
	Args   []interface{}
} {
	var calls []struct {
		Format string
		Args   []interface{}
	}
	mock.lockPanicf.RLock()
	calls = mock.calls.Panicf
	mock.lockPanicf.RUnlock()
	return calls
}

// Print calls PrintFunc.
func (mock *LogMock) Print(args ...interface{}) {
	if mock.PrintFunc == nil {
		panic("LogMock.PrintFunc: method is nil but Log.Print was just called")
	}
	callInfo := struct {
		Args []interface{}
	}{
		Args: args,
	}
	mock.lockPrint.Lock()
	mock.calls.Print = append(mock.calls.Print, callInfo)
	mock.lockPrint.Unlock()
	mock.PrintFunc(args...)
}

// PrintCalls gets all the calls that were made to Print.
// Check the length with:
//     len(mockedLog.PrintCalls())
func (mock *LogMock) PrintCalls() []struct {
	Args []interface{}
} {
	var calls []struct {
		Args []interface{}
	}
	mock.lockPrint.RLock()
	calls = mock.calls.Print
	mock.lockPrint.RUnlock()
	return calls
}

// Printf calls PrintfFunc.
func (mock *LogMock) Printf(format string, args ...interface{}) {
	if mock.PrintfFunc == nil {
		panic("LogMock.PrintfFunc: method is nil but Log.Printf was just called")
	}
	callInfo := struct {
		Format string
		Args   []interface{}
	}{
		Format: format,
		Args:   args,
	}
	mock.lockPrintf.Lock()
	mock.calls.Printf = append(mock.calls.Printf, callInfo)
	mock.lockPrintf.Unlock()
	mock.PrintfFunc(format, args...)
}

// PrintfCalls gets all the calls that were made to Printf.
// Check the length with:
//     len(mockedLog.PrintfCalls())
func (mock *LogMock) PrintfCalls() []struct {
	Format string
	Args   []interface{}
} {
	var calls []struct {
		Format string
		Args   []interface{}
	}
	mock.lockPrintf.RLock()
	calls = mock.calls.Printf
	mock.lockPrintf.RUnlock()
	return calls
}

// Ensure, that DispatcherMock does implement weos.Dispatcher.
// If this is not the case, regenerate this file with moq.
var _ weos.Dispatcher = &DispatcherMock{}

// DispatcherMock is a mock implementation of weos.Dispatcher.
//
//     func TestSomethingThatUsesDispatcher(t *testing.T) {
//
//         // make and configure a mocked weos.Dispatcher
//         mockedDispatcher := &DispatcherMock{
//             AddSubscriberFunc: func(command *weos.Command, handler weos.CommandHandler) map[string][]weos.CommandHandler {
// 	               panic("mock out the AddSubscriber method")
//             },
//             DispatchFunc: func(ctx context.Context, command *weos.Command) error {
// 	               panic("mock out the Dispatch method")
//             },
//             GetSubscribersFunc: func() map[string][]weos.CommandHandler {
// 	               panic("mock out the GetSubscribers method")
//             },
//         }
//
//         // use mockedDispatcher in code that requires weos.Dispatcher
//         // and then make assertions.
//
//     }
type DispatcherMock struct {
	// AddSubscriberFunc mocks the AddSubscriber method.
	AddSubscriberFunc func(command *weos.Command, handler weos.CommandHandler) map[string][]weos.CommandHandler

	// DispatchFunc mocks the Dispatch method.
	DispatchFunc func(ctx context.Context, command *weos.Command) error

	// GetSubscribersFunc mocks the GetSubscribers method.
	GetSubscribersFunc func() map[string][]weos.CommandHandler

	// calls tracks calls to the methods.
	calls struct {
		// AddSubscriber holds details about calls to the AddSubscriber method.
		AddSubscriber []struct {
			// Command is the command argument value.
			Command *weos.Command
			// Handler is the handler argument value.
			Handler weos.CommandHandler
		}
		// Dispatch holds details about calls to the Dispatch method.
		Dispatch []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Command is the command argument value.
			Command *weos.Command
		}
		// GetSubscribers holds details about calls to the GetSubscribers method.
		GetSubscribers []struct {
		}
	}
	lockAddSubscriber  sync.RWMutex
	lockDispatch       sync.RWMutex
	lockGetSubscribers sync.RWMutex
}

// AddSubscriber calls AddSubscriberFunc.
func (mock *DispatcherMock) AddSubscriber(command *weos.Command, handler weos.CommandHandler) map[string][]weos.CommandHandler {
	if mock.AddSubscriberFunc == nil {
		panic("DispatcherMock.AddSubscriberFunc: method is nil but Dispatcher.AddSubscriber was just called")
	}
	callInfo := struct {
		Command *weos.Command
		Handler weos.CommandHandler
	}{
		Command: command,
		Handler: handler,
	}
	mock.lockAddSubscriber.Lock()
	mock.calls.AddSubscriber = append(mock.calls.AddSubscriber, callInfo)
	mock.lockAddSubscriber.Unlock()
	return mock.AddSubscriberFunc(command, handler)
}

// AddSubscriberCalls gets all the calls that were made to AddSubscriber.
// Check the length with:
//     len(mockedDispatcher.AddSubscriberCalls())
func (mock *DispatcherMock) AddSubscriberCalls() []struct {
	Command *weos.Command
	Handler weos.CommandHandler
} {
	var calls []struct {
		Command *weos.Command
		Handler weos.CommandHandler
	}
	mock.lockAddSubscriber.RLock()
	calls = mock.calls.AddSubscriber
	mock.lockAddSubscriber.RUnlock()
	return calls
}

// Dispatch calls DispatchFunc.
func (mock *DispatcherMock) Dispatch(ctx context.Context, command *weos.Command) error {
	if mock.DispatchFunc == nil {
		panic("DispatcherMock.DispatchFunc: method is nil but Dispatcher.Dispatch was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Command *weos.Command
	}{
		Ctx:     ctx,
		Command: command,
	}
	mock.lockDispatch.Lock()
	mock.calls.Dispatch = append(mock.calls.Dispatch, callInfo)
	mock.lockDispatch.Unlock()
	return mock.DispatchFunc(ctx, command)
}

// DispatchCalls gets all the calls that were made to Dispatch.
// Check the length with:
//     len(mockedDispatcher.DispatchCalls())
func (mock *DispatcherMock) DispatchCalls() []struct {
	Ctx     context.Context
	Command *weos.Command
} {
	var calls []struct {
		Ctx     context.Context
		Command *weos.Command
	}
	mock.lockDispatch.RLock()
	calls = mock.calls.Dispatch
	mock.lockDispatch.RUnlock()
	return calls
}

// GetSubscribers calls GetSubscribersFunc.
func (mock *DispatcherMock) GetSubscribers() map[string][]weos.CommandHandler {
	if mock.GetSubscribersFunc == nil {
		panic("DispatcherMock.GetSubscribersFunc: method is nil but Dispatcher.GetSubscribers was just called")
	}
	callInfo := struct {
	}{}
	mock.lockGetSubscribers.Lock()
	mock.calls.GetSubscribers = append(mock.calls.GetSubscribers, callInfo)
	mock.lockGetSubscribers.Unlock()
	return mock.GetSubscribersFunc()
}

// GetSubscribersCalls gets all the calls that were made to GetSubscribers.
// Check the length with:
//     len(mockedDispatcher.GetSubscribersCalls())
func (mock *DispatcherMock) GetSubscribersCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockGetSubscribers.RLock()
	calls = mock.calls.GetSubscribers
	mock.lockGetSubscribers.RUnlock()
	return calls
}

// Ensure, that ApplicationMock does implement weos.Service.
// If this is not the case, regenerate this file with moq.
var _ weos.Service = &ApplicationMock{}

// ApplicationMock is a mock implementation of weos.Service.
//
//     func TestSomethingThatUsesApplication(t *testing.T) {
//
//         // make and configure a mocked weos.Service
//         mockedApplication := &ApplicationMock{
//             AddProjectionFunc: func(projection weos.Projection) error {
// 	               panic("mock out the AddProjection method")
//             },
//             ConfigFunc: func() *weos.ServiceConfig {
// 	               panic("mock out the Config method")
//             },
//             DBFunc: func() *gorm.DB {
// 	               panic("mock out the DB method")
//             },
//             DBConnectionFunc: func() *sql.DB {
// 	               panic("mock out the DBConnection method")
//             },
//             DispatcherFunc: func() weos.Dispatcher {
// 	               panic("mock out the Dispatcher method")
//             },
//             EventRepositoryFunc: func() weos.EventRepository {
// 	               panic("mock out the EventRepository method")
//             },
//             HTTPClientFunc: func() *http.Client {
// 	               panic("mock out the HTTPClient method")
//             },
//             IDFunc: func() string {
// 	               panic("mock out the ID method")
//             },
//             LoggerFunc: func() weos.Log {
// 	               panic("mock out the Logger method")
//             },
//             MigrateFunc: func(ctx context.Context) error {
// 	               panic("mock out the Migrate method")
//             },
//             ProjectionsFunc: func() []weos.Projection {
// 	               panic("mock out the Projections method")
//             },
//             TitleFunc: func() string {
// 	               panic("mock out the Title method")
//             },
//         }
//
//         // use mockedApplication in code that requires weos.Service
//         // and then make assertions.
//
//     }
type ApplicationMock struct {
	// AddProjectionFunc mocks the AddProjection method.
	AddProjectionFunc func(projection weos.Projection) error

	// ConfigFunc mocks the Config method.
	ConfigFunc func() *weos.ServiceConfig

	// DBFunc mocks the DB method.
	DBFunc func() *gorm.DB

	// DBConnectionFunc mocks the DBConnection method.
	DBConnectionFunc func() *sql.DB

	// DispatcherFunc mocks the Dispatcher method.
	DispatcherFunc func() weos.Dispatcher

	// EventRepositoryFunc mocks the EventRepository method.
	EventRepositoryFunc func() weos.EventRepository

	// HTTPClientFunc mocks the HTTPClient method.
	HTTPClientFunc func() *http.Client

	// IDFunc mocks the ID method.
	IDFunc func() string

	// LoggerFunc mocks the Logger method.
	LoggerFunc func() weos.Log

	// MigrateFunc mocks the Migrate method.
	MigrateFunc func(ctx context.Context) error

	// ProjectionsFunc mocks the Projections method.
	ProjectionsFunc func() []weos.Projection

	// TitleFunc mocks the Title method.
	TitleFunc func() string

	// calls tracks calls to the methods.
	calls struct {
		// AddProjection holds details about calls to the AddProjection method.
		AddProjection []struct {
			// Projection is the projection argument value.
			Projection weos.Projection
		}
		// Config holds details about calls to the Config method.
		Config []struct {
		}
		// DB holds details about calls to the DB method.
		DB []struct {
		}
		// DBConnection holds details about calls to the DBConnection method.
		DBConnection []struct {
		}
		// Dispatcher holds details about calls to the Dispatcher method.
		Dispatcher []struct {
		}
		// EventRepository holds details about calls to the EventRepository method.
		EventRepository []struct {
		}
		// HTTPClient holds details about calls to the HTTPClient method.
		HTTPClient []struct {
		}
		// ID holds details about calls to the ID method.
		ID []struct {
		}
		// Logger holds details about calls to the Logger method.
		Logger []struct {
		}
		// Migrate holds details about calls to the Migrate method.
		Migrate []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// Projections holds details about calls to the Projections method.
		Projections []struct {
		}
		// Title holds details about calls to the Title method.
		Title []struct {
		}
	}
	lockAddProjection   sync.RWMutex
	lockConfig          sync.RWMutex
	lockDB              sync.RWMutex
	lockDBConnection    sync.RWMutex
	lockDispatcher      sync.RWMutex
	lockEventRepository sync.RWMutex
	lockHTTPClient      sync.RWMutex
	lockID              sync.RWMutex
	lockLogger          sync.RWMutex
	lockMigrate         sync.RWMutex
	lockProjections     sync.RWMutex
	lockTitle           sync.RWMutex
}

// AddProjection calls AddProjectionFunc.
func (mock *ApplicationMock) AddProjection(projection weos.Projection) error {
	if mock.AddProjectionFunc == nil {
		panic("ApplicationMock.AddProjectionFunc: method is nil but Service.AddProjection was just called")
	}
	callInfo := struct {
		Projection weos.Projection
	}{
		Projection: projection,
	}
	mock.lockAddProjection.Lock()
	mock.calls.AddProjection = append(mock.calls.AddProjection, callInfo)
	mock.lockAddProjection.Unlock()
	return mock.AddProjectionFunc(projection)
}

// AddProjectionCalls gets all the calls that were made to AddProjection.
// Check the length with:
//     len(mockedApplication.AddProjectionCalls())
func (mock *ApplicationMock) AddProjectionCalls() []struct {
	Projection weos.Projection
} {
	var calls []struct {
		Projection weos.Projection
	}
	mock.lockAddProjection.RLock()
	calls = mock.calls.AddProjection
	mock.lockAddProjection.RUnlock()
	return calls
}

// Config calls ConfigFunc.
func (mock *ApplicationMock) Config() *weos.ServiceConfig {
	if mock.ConfigFunc == nil {
		panic("ApplicationMock.ConfigFunc: method is nil but Service.Config was just called")
	}
	callInfo := struct {
	}{}
	mock.lockConfig.Lock()
	mock.calls.Config = append(mock.calls.Config, callInfo)
	mock.lockConfig.Unlock()
	return mock.ConfigFunc()
}

// ConfigCalls gets all the calls that were made to Config.
// Check the length with:
//     len(mockedApplication.ConfigCalls())
func (mock *ApplicationMock) ConfigCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockConfig.RLock()
	calls = mock.calls.Config
	mock.lockConfig.RUnlock()
	return calls
}

// DB calls DBFunc.
func (mock *ApplicationMock) DB() *gorm.DB {
	if mock.DBFunc == nil {
		panic("ApplicationMock.DBFunc: method is nil but Service.DB was just called")
	}
	callInfo := struct {
	}{}
	mock.lockDB.Lock()
	mock.calls.DB = append(mock.calls.DB, callInfo)
	mock.lockDB.Unlock()
	return mock.DBFunc()
}

// DBCalls gets all the calls that were made to DB.
// Check the length with:
//     len(mockedApplication.DBCalls())
func (mock *ApplicationMock) DBCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockDB.RLock()
	calls = mock.calls.DB
	mock.lockDB.RUnlock()
	return calls
}

// DBConnection calls DBConnectionFunc.
func (mock *ApplicationMock) DBConnection() *sql.DB {
	if mock.DBConnectionFunc == nil {
		panic("ApplicationMock.DBConnectionFunc: method is nil but Service.DBConnection was just called")
	}
	callInfo := struct {
	}{}
	mock.lockDBConnection.Lock()
	mock.calls.DBConnection = append(mock.calls.DBConnection, callInfo)
	mock.lockDBConnection.Unlock()
	return mock.DBConnectionFunc()
}

// DBConnectionCalls gets all the calls that were made to DBConnection.
// Check the length with:
//     len(mockedApplication.DBConnectionCalls())
func (mock *ApplicationMock) DBConnectionCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockDBConnection.RLock()
	calls = mock.calls.DBConnection
	mock.lockDBConnection.RUnlock()
	return calls
}

// Dispatcher calls DispatcherFunc.
func (mock *ApplicationMock) Dispatcher() weos.Dispatcher {
	if mock.DispatcherFunc == nil {
		panic("ApplicationMock.DispatcherFunc: method is nil but Service.Dispatcher was just called")
	}
	callInfo := struct {
	}{}
	mock.lockDispatcher.Lock()
	mock.calls.Dispatcher = append(mock.calls.Dispatcher, callInfo)
	mock.lockDispatcher.Unlock()
	return mock.DispatcherFunc()
}

// DispatcherCalls gets all the calls that were made to Dispatcher.
// Check the length with:
//     len(mockedApplication.DispatcherCalls())
func (mock *ApplicationMock) DispatcherCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockDispatcher.RLock()
	calls = mock.calls.Dispatcher
	mock.lockDispatcher.RUnlock()
	return calls
}

// EventRepository calls EventRepositoryFunc.
func (mock *ApplicationMock) EventRepository() weos.EventRepository {
	if mock.EventRepositoryFunc == nil {
		panic("ApplicationMock.EventRepositoryFunc: method is nil but Service.EventRepository was just called")
	}
	callInfo := struct {
	}{}
	mock.lockEventRepository.Lock()
	mock.calls.EventRepository = append(mock.calls.EventRepository, callInfo)
	mock.lockEventRepository.Unlock()
	return mock.EventRepositoryFunc()
}

// EventRepositoryCalls gets all the calls that were made to EventRepository.
// Check the length with:
//     len(mockedApplication.EventRepositoryCalls())
func (mock *ApplicationMock) EventRepositoryCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockEventRepository.RLock()
	calls = mock.calls.EventRepository
	mock.lockEventRepository.RUnlock()
	return calls
}

// HTTPClient calls HTTPClientFunc.
func (mock *ApplicationMock) HTTPClient() *http.Client {
	if mock.HTTPClientFunc == nil {
		panic("ApplicationMock.HTTPClientFunc: method is nil but Service.HTTPClient was just called")
	}
	callInfo := struct {
	}{}
	mock.lockHTTPClient.Lock()
	mock.calls.HTTPClient = append(mock.calls.HTTPClient, callInfo)
	mock.lockHTTPClient.Unlock()
	return mock.HTTPClientFunc()
}

// HTTPClientCalls gets all the calls that were made to HTTPClient.
// Check the length with:
//     len(mockedApplication.HTTPClientCalls())
func (mock *ApplicationMock) HTTPClientCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockHTTPClient.RLock()
	calls = mock.calls.HTTPClient
	mock.lockHTTPClient.RUnlock()
	return calls
}

// ID calls IDFunc.
func (mock *ApplicationMock) ID() string {
	if mock.IDFunc == nil {
		panic("ApplicationMock.IDFunc: method is nil but Service.ID was just called")
	}
	callInfo := struct {
	}{}
	mock.lockID.Lock()
	mock.calls.ID = append(mock.calls.ID, callInfo)
	mock.lockID.Unlock()
	return mock.IDFunc()
}

// IDCalls gets all the calls that were made to ID.
// Check the length with:
//     len(mockedApplication.IDCalls())
func (mock *ApplicationMock) IDCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockID.RLock()
	calls = mock.calls.ID
	mock.lockID.RUnlock()
	return calls
}

// Logger calls LoggerFunc.
func (mock *ApplicationMock) Logger() weos.Log {
	if mock.LoggerFunc == nil {
		panic("ApplicationMock.LoggerFunc: method is nil but Service.Logger was just called")
	}
	callInfo := struct {
	}{}
	mock.lockLogger.Lock()
	mock.calls.Logger = append(mock.calls.Logger, callInfo)
	mock.lockLogger.Unlock()
	return mock.LoggerFunc()
}

// LoggerCalls gets all the calls that were made to Logger.
// Check the length with:
//     len(mockedApplication.LoggerCalls())
func (mock *ApplicationMock) LoggerCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockLogger.RLock()
	calls = mock.calls.Logger
	mock.lockLogger.RUnlock()
	return calls
}

// Migrate calls MigrateFunc.
func (mock *ApplicationMock) Migrate(ctx context.Context) error {
	if mock.MigrateFunc == nil {
		panic("ApplicationMock.MigrateFunc: method is nil but Service.Migrate was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockMigrate.Lock()
	mock.calls.Migrate = append(mock.calls.Migrate, callInfo)
	mock.lockMigrate.Unlock()
	return mock.MigrateFunc(ctx)
}

// MigrateCalls gets all the calls that were made to Migrate.
// Check the length with:
//     len(mockedApplication.MigrateCalls())
func (mock *ApplicationMock) MigrateCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockMigrate.RLock()
	calls = mock.calls.Migrate
	mock.lockMigrate.RUnlock()
	return calls
}

// Projections calls ProjectionsFunc.
func (mock *ApplicationMock) Projections() []weos.Projection {
	if mock.ProjectionsFunc == nil {
		panic("ApplicationMock.ProjectionsFunc: method is nil but Service.Projections was just called")
	}
	callInfo := struct {
	}{}
	mock.lockProjections.Lock()
	mock.calls.Projections = append(mock.calls.Projections, callInfo)
	mock.lockProjections.Unlock()
	return mock.ProjectionsFunc()
}

// ProjectionsCalls gets all the calls that were made to Projections.
// Check the length with:
//     len(mockedApplication.ProjectionsCalls())
func (mock *ApplicationMock) ProjectionsCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockProjections.RLock()
	calls = mock.calls.Projections
	mock.lockProjections.RUnlock()
	return calls
}

// Title calls TitleFunc.
func (mock *ApplicationMock) Title() string {
	if mock.TitleFunc == nil {
		panic("ApplicationMock.TitleFunc: method is nil but Service.Title was just called")
	}
	callInfo := struct {
	}{}
	mock.lockTitle.Lock()
	mock.calls.Title = append(mock.calls.Title, callInfo)
	mock.lockTitle.Unlock()
	return mock.TitleFunc()
}

// TitleCalls gets all the calls that were made to Title.
// Check the length with:
//     len(mockedApplication.TitleCalls())
func (mock *ApplicationMock) TitleCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockTitle.RLock()
	calls = mock.calls.Title
	mock.lockTitle.RUnlock()
	return calls
}

var _ weos.Projection = &ProjectionMock{}

// ProjectionMock is a mock implementation of model.Projection.
//
// 	func TestSomethingThatUsesProjection(t *testing.T) {
//
// 		// make and configure a mocked model.Projection
// 		mockedProjection := &ProjectionMock{
// 			GetByKeyFunc: func(ctxt context.Context, contentType *context2.ContentType, identifiers map[string]interface{}) (map[string]interface{}, error) {
// 				panic("mock out the GetByKey method")
// 			},
// 			GetContentEntityFunc: func(ctx context.Context, weosID string) (*model.ContentEntity, error) {
// 				panic("mock out the GetContentEntity method")
// 			},
// 			GetEventHandlerFunc: func() model.EventHandler {
// 				panic("mock out the GetEventHandler method")
// 			},
// 			MigrateFunc: func(ctx context.Context) error {
// 				panic("mock out the Migrate method")
// 			},
// 		}
//
// 		// use mockedProjection in code that requires model.Projection
// 		// and then make assertions.
//
// 	}
type ProjectionMock struct {
	// GetByKeyFunc mocks the GetByKey method.
	GetByKeyFunc func(ctxt context.Context, contentType *context2.ContentType, identifiers map[string]interface{}) (map[string]interface{}, error)

	// GetContentEntityFunc mocks the GetContentEntity method.
	GetContentEntityFunc func(ctx context.Context, weosID string) (*weos.ContentEntity, error)

	// GetEventHandlerFunc mocks the GetEventHandler method.
	GetEventHandlerFunc func() weos.EventHandler

	// MigrateFunc mocks the Migrate method.
	MigrateFunc func(ctx context.Context) error

	// calls tracks calls to the methods.
	calls struct {
		// GetByKey holds details about calls to the GetByKey method.
		GetByKey []struct {
			// Ctxt is the ctxt argument value.
			Ctxt context.Context
			// ContentType is the contentType argument value.
			ContentType *context2.ContentType
			// Identifiers is the identifiers argument value.
			Identifiers map[string]interface{}
		}
		// GetContentEntity holds details about calls to the GetContentEntity method.
		GetContentEntity []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// WeosID is the weosID argument value.
			WeosID string
		}
		// GetEventHandler holds details about calls to the GetEventHandler method.
		GetEventHandler []struct {
		}
		// Migrate holds details about calls to the Migrate method.
		Migrate []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
	}
	lockGetByKey         sync.RWMutex
	lockGetContentEntity sync.RWMutex
	lockGetEventHandler  sync.RWMutex
	lockMigrate          sync.RWMutex
}

// GetByKey calls GetByKeyFunc.
func (mock *ProjectionMock) GetByKey(ctxt context.Context, contentType *context2.ContentType, identifiers map[string]interface{}) (map[string]interface{}, error) {
	if mock.GetByKeyFunc == nil {
		panic("ProjectionMock.GetByKeyFunc: method is nil but Projection.GetByKey was just called")
	}
	callInfo := struct {
		Ctxt        context.Context
		ContentType *context2.ContentType
		Identifiers map[string]interface{}
	}{
		Ctxt:        ctxt,
		ContentType: contentType,
		Identifiers: identifiers,
	}
	mock.lockGetByKey.Lock()
	mock.calls.GetByKey = append(mock.calls.GetByKey, callInfo)
	mock.lockGetByKey.Unlock()
	return mock.GetByKeyFunc(ctxt, contentType, identifiers)
}

// GetByKeyCalls gets all the calls that were made to GetByKey.
// Check the length with:
//     len(mockedProjection.GetByKeyCalls())
func (mock *ProjectionMock) GetByKeyCalls() []struct {
	Ctxt        context.Context
	ContentType *context2.ContentType
	Identifiers map[string]interface{}
} {
	var calls []struct {
		Ctxt        context.Context
		ContentType *context2.ContentType
		Identifiers map[string]interface{}
	}
	mock.lockGetByKey.RLock()
	calls = mock.calls.GetByKey
	mock.lockGetByKey.RUnlock()
	return calls
}

// GetContentEntity calls GetContentEntityFunc.
func (mock *ProjectionMock) GetContentEntity(ctx context.Context, weosID string) (*weos.ContentEntity, error) {
	if mock.GetContentEntityFunc == nil {
		panic("ProjectionMock.GetContentEntityFunc: method is nil but Projection.GetContentEntity was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		WeosID string
	}{
		Ctx:    ctx,
		WeosID: weosID,
	}
	mock.lockGetContentEntity.Lock()
	mock.calls.GetContentEntity = append(mock.calls.GetContentEntity, callInfo)
	mock.lockGetContentEntity.Unlock()
	return mock.GetContentEntityFunc(ctx, weosID)
}

// GetContentEntityCalls gets all the calls that were made to GetContentEntity.
// Check the length with:
//     len(mockedProjection.GetContentEntityCalls())
func (mock *ProjectionMock) GetContentEntityCalls() []struct {
	Ctx    context.Context
	WeosID string
} {
	var calls []struct {
		Ctx    context.Context
		WeosID string
	}
	mock.lockGetContentEntity.RLock()
	calls = mock.calls.GetContentEntity
	mock.lockGetContentEntity.RUnlock()
	return calls
}

// GetEventHandler calls GetEventHandlerFunc.
func (mock *ProjectionMock) GetEventHandler() weos.EventHandler {
	if mock.GetEventHandlerFunc == nil {
		panic("ProjectionMock.GetEventHandlerFunc: method is nil but Projection.GetEventHandler was just called")
	}
	callInfo := struct {
	}{}
	mock.lockGetEventHandler.Lock()
	mock.calls.GetEventHandler = append(mock.calls.GetEventHandler, callInfo)
	mock.lockGetEventHandler.Unlock()
	return mock.GetEventHandlerFunc()
}

// GetEventHandlerCalls gets all the calls that were made to GetEventHandler.
// Check the length with:
//     len(mockedProjection.GetEventHandlerCalls())
func (mock *ProjectionMock) GetEventHandlerCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockGetEventHandler.RLock()
	calls = mock.calls.GetEventHandler
	mock.lockGetEventHandler.RUnlock()
	return calls
}

// Migrate calls MigrateFunc.
func (mock *ProjectionMock) Migrate(ctx context.Context) error {
	if mock.MigrateFunc == nil {
		panic("ProjectionMock.MigrateFunc: method is nil but Projection.Migrate was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockMigrate.Lock()
	mock.calls.Migrate = append(mock.calls.Migrate, callInfo)
	mock.lockMigrate.Unlock()
	return mock.MigrateFunc(ctx)
}

// MigrateCalls gets all the calls that were made to Migrate.
// Check the length with:
//     len(mockedProjection.MigrateCalls())
func (mock *ProjectionMock) MigrateCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockMigrate.RLock()
	calls = mock.calls.Migrate
	mock.lockMigrate.RUnlock()
	return calls
}

