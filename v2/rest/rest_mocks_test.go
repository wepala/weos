// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package rest_test

import (
	"context"
	"github.com/wepala/weos/v2/rest"
	"sync"
)

// Ensure, that LogMock does implement rest.Log.
// If this is not the case, regenerate this file with moq.
var _ rest.Log = &LogMock{}

// LogMock is a mock implementation of rest.Log.
//
//	func TestSomethingThatUsesLog(t *testing.T) {
//
//		// make and configure a mocked rest.Log
//		mockedLog := &LogMock{
//			DebugFunc: func(args ...interface{})  {
//				panic("mock out the Debug method")
//			},
//			DebugfFunc: func(format string, args ...interface{})  {
//				panic("mock out the Debugf method")
//			},
//			ErrorFunc: func(args ...interface{})  {
//				panic("mock out the Error method")
//			},
//			ErrorfFunc: func(format string, args ...interface{})  {
//				panic("mock out the Errorf method")
//			},
//			FatalFunc: func(args ...interface{})  {
//				panic("mock out the Fatal method")
//			},
//			FatalfFunc: func(format string, args ...interface{})  {
//				panic("mock out the Fatalf method")
//			},
//			InfoFunc: func(args ...interface{})  {
//				panic("mock out the Info method")
//			},
//			InfofFunc: func(format string, args ...interface{})  {
//				panic("mock out the Infof method")
//			},
//			PanicFunc: func(args ...interface{})  {
//				panic("mock out the Panic method")
//			},
//			PanicfFunc: func(format string, args ...interface{})  {
//				panic("mock out the Panicf method")
//			},
//			PrintFunc: func(args ...interface{})  {
//				panic("mock out the Print method")
//			},
//			PrintfFunc: func(format string, args ...interface{})  {
//				panic("mock out the Printf method")
//			},
//			WarnFunc: func(args ...interface{})  {
//				panic("mock out the Warn method")
//			},
//			WarnfFunc: func(format string, args ...interface{})  {
//				panic("mock out the Warnf method")
//			},
//		}
//
//		// use mockedLog in code that requires rest.Log
//		// and then make assertions.
//
//	}
type LogMock struct {
	// DebugFunc mocks the Debug method.
	DebugFunc func(args ...interface{})

	// DebugfFunc mocks the Debugf method.
	DebugfFunc func(format string, args ...interface{})

	// ErrorFunc mocks the Error method.
	ErrorFunc func(args ...interface{})

	// ErrorfFunc mocks the Errorf method.
	ErrorfFunc func(format string, args ...interface{})

	// FatalFunc mocks the Fatal method.
	FatalFunc func(args ...interface{})

	// FatalfFunc mocks the Fatalf method.
	FatalfFunc func(format string, args ...interface{})

	// InfoFunc mocks the Info method.
	InfoFunc func(args ...interface{})

	// InfofFunc mocks the Infof method.
	InfofFunc func(format string, args ...interface{})

	// PanicFunc mocks the Panic method.
	PanicFunc func(args ...interface{})

	// PanicfFunc mocks the Panicf method.
	PanicfFunc func(format string, args ...interface{})

	// PrintFunc mocks the Print method.
	PrintFunc func(args ...interface{})

	// PrintfFunc mocks the Printf method.
	PrintfFunc func(format string, args ...interface{})

	// WarnFunc mocks the Warn method.
	WarnFunc func(args ...interface{})

	// WarnfFunc mocks the Warnf method.
	WarnfFunc func(format string, args ...interface{})

	// calls tracks calls to the methods.
	calls struct {
		// Debug holds details about calls to the Debug method.
		Debug []struct {
			// Args is the args argument value.
			Args []interface{}
		}
		// Debugf holds details about calls to the Debugf method.
		Debugf []struct {
			// Format is the format argument value.
			Format string
			// Args is the args argument value.
			Args []interface{}
		}
		// Error holds details about calls to the Error method.
		Error []struct {
			// Args is the args argument value.
			Args []interface{}
		}
		// Errorf holds details about calls to the Errorf method.
		Errorf []struct {
			// Format is the format argument value.
			Format string
			// Args is the args argument value.
			Args []interface{}
		}
		// Fatal holds details about calls to the Fatal method.
		Fatal []struct {
			// Args is the args argument value.
			Args []interface{}
		}
		// Fatalf holds details about calls to the Fatalf method.
		Fatalf []struct {
			// Format is the format argument value.
			Format string
			// Args is the args argument value.
			Args []interface{}
		}
		// Info holds details about calls to the Info method.
		Info []struct {
			// Args is the args argument value.
			Args []interface{}
		}
		// Infof holds details about calls to the Infof method.
		Infof []struct {
			// Format is the format argument value.
			Format string
			// Args is the args argument value.
			Args []interface{}
		}
		// Panic holds details about calls to the Panic method.
		Panic []struct {
			// Args is the args argument value.
			Args []interface{}
		}
		// Panicf holds details about calls to the Panicf method.
		Panicf []struct {
			// Format is the format argument value.
			Format string
			// Args is the args argument value.
			Args []interface{}
		}
		// Print holds details about calls to the Print method.
		Print []struct {
			// Args is the args argument value.
			Args []interface{}
		}
		// Printf holds details about calls to the Printf method.
		Printf []struct {
			// Format is the format argument value.
			Format string
			// Args is the args argument value.
			Args []interface{}
		}
		// Warn holds details about calls to the Warn method.
		Warn []struct {
			// Args is the args argument value.
			Args []interface{}
		}
		// Warnf holds details about calls to the Warnf method.
		Warnf []struct {
			// Format is the format argument value.
			Format string
			// Args is the args argument value.
			Args []interface{}
		}
	}
	lockDebug  sync.RWMutex
	lockDebugf sync.RWMutex
	lockError  sync.RWMutex
	lockErrorf sync.RWMutex
	lockFatal  sync.RWMutex
	lockFatalf sync.RWMutex
	lockInfo   sync.RWMutex
	lockInfof  sync.RWMutex
	lockPanic  sync.RWMutex
	lockPanicf sync.RWMutex
	lockPrint  sync.RWMutex
	lockPrintf sync.RWMutex
	lockWarn   sync.RWMutex
	lockWarnf  sync.RWMutex
}

// Debug calls DebugFunc.
func (mock *LogMock) Debug(args ...interface{}) {
	if mock.DebugFunc == nil {
		panic("LogMock.DebugFunc: method is nil but Log.Debug was just called")
	}
	callInfo := struct {
		Args []interface{}
	}{
		Args: args,
	}
	mock.lockDebug.Lock()
	mock.calls.Debug = append(mock.calls.Debug, callInfo)
	mock.lockDebug.Unlock()
	mock.DebugFunc(args...)
}

// DebugCalls gets all the calls that were made to Debug.
// Check the length with:
//
//	len(mockedLog.DebugCalls())
func (mock *LogMock) DebugCalls() []struct {
	Args []interface{}
} {
	var calls []struct {
		Args []interface{}
	}
	mock.lockDebug.RLock()
	calls = mock.calls.Debug
	mock.lockDebug.RUnlock()
	return calls
}

// Debugf calls DebugfFunc.
func (mock *LogMock) Debugf(format string, args ...interface{}) {
	if mock.DebugfFunc == nil {
		panic("LogMock.DebugfFunc: method is nil but Log.Debugf was just called")
	}
	callInfo := struct {
		Format string
		Args   []interface{}
	}{
		Format: format,
		Args:   args,
	}
	mock.lockDebugf.Lock()
	mock.calls.Debugf = append(mock.calls.Debugf, callInfo)
	mock.lockDebugf.Unlock()
	mock.DebugfFunc(format, args...)
}

// DebugfCalls gets all the calls that were made to Debugf.
// Check the length with:
//
//	len(mockedLog.DebugfCalls())
func (mock *LogMock) DebugfCalls() []struct {
	Format string
	Args   []interface{}
} {
	var calls []struct {
		Format string
		Args   []interface{}
	}
	mock.lockDebugf.RLock()
	calls = mock.calls.Debugf
	mock.lockDebugf.RUnlock()
	return calls
}

// Error calls ErrorFunc.
func (mock *LogMock) Error(args ...interface{}) {
	if mock.ErrorFunc == nil {
		panic("LogMock.ErrorFunc: method is nil but Log.Error was just called")
	}
	callInfo := struct {
		Args []interface{}
	}{
		Args: args,
	}
	mock.lockError.Lock()
	mock.calls.Error = append(mock.calls.Error, callInfo)
	mock.lockError.Unlock()
	mock.ErrorFunc(args...)
}

// ErrorCalls gets all the calls that were made to Error.
// Check the length with:
//
//	len(mockedLog.ErrorCalls())
func (mock *LogMock) ErrorCalls() []struct {
	Args []interface{}
} {
	var calls []struct {
		Args []interface{}
	}
	mock.lockError.RLock()
	calls = mock.calls.Error
	mock.lockError.RUnlock()
	return calls
}

// Errorf calls ErrorfFunc.
func (mock *LogMock) Errorf(format string, args ...interface{}) {
	if mock.ErrorfFunc == nil {
		panic("LogMock.ErrorfFunc: method is nil but Log.Errorf was just called")
	}
	callInfo := struct {
		Format string
		Args   []interface{}
	}{
		Format: format,
		Args:   args,
	}
	mock.lockErrorf.Lock()
	mock.calls.Errorf = append(mock.calls.Errorf, callInfo)
	mock.lockErrorf.Unlock()
	mock.ErrorfFunc(format, args...)
}

// ErrorfCalls gets all the calls that were made to Errorf.
// Check the length with:
//
//	len(mockedLog.ErrorfCalls())
func (mock *LogMock) ErrorfCalls() []struct {
	Format string
	Args   []interface{}
} {
	var calls []struct {
		Format string
		Args   []interface{}
	}
	mock.lockErrorf.RLock()
	calls = mock.calls.Errorf
	mock.lockErrorf.RUnlock()
	return calls
}

// Fatal calls FatalFunc.
func (mock *LogMock) Fatal(args ...interface{}) {
	if mock.FatalFunc == nil {
		panic("LogMock.FatalFunc: method is nil but Log.Fatal was just called")
	}
	callInfo := struct {
		Args []interface{}
	}{
		Args: args,
	}
	mock.lockFatal.Lock()
	mock.calls.Fatal = append(mock.calls.Fatal, callInfo)
	mock.lockFatal.Unlock()
	mock.FatalFunc(args...)
}

// FatalCalls gets all the calls that were made to Fatal.
// Check the length with:
//
//	len(mockedLog.FatalCalls())
func (mock *LogMock) FatalCalls() []struct {
	Args []interface{}
} {
	var calls []struct {
		Args []interface{}
	}
	mock.lockFatal.RLock()
	calls = mock.calls.Fatal
	mock.lockFatal.RUnlock()
	return calls
}

// Fatalf calls FatalfFunc.
func (mock *LogMock) Fatalf(format string, args ...interface{}) {
	if mock.FatalfFunc == nil {
		panic("LogMock.FatalfFunc: method is nil but Log.Fatalf was just called")
	}
	callInfo := struct {
		Format string
		Args   []interface{}
	}{
		Format: format,
		Args:   args,
	}
	mock.lockFatalf.Lock()
	mock.calls.Fatalf = append(mock.calls.Fatalf, callInfo)
	mock.lockFatalf.Unlock()
	mock.FatalfFunc(format, args...)
}

// FatalfCalls gets all the calls that were made to Fatalf.
// Check the length with:
//
//	len(mockedLog.FatalfCalls())
func (mock *LogMock) FatalfCalls() []struct {
	Format string
	Args   []interface{}
} {
	var calls []struct {
		Format string
		Args   []interface{}
	}
	mock.lockFatalf.RLock()
	calls = mock.calls.Fatalf
	mock.lockFatalf.RUnlock()
	return calls
}

// Info calls InfoFunc.
func (mock *LogMock) Info(args ...interface{}) {
	if mock.InfoFunc == nil {
		panic("LogMock.InfoFunc: method is nil but Log.Info was just called")
	}
	callInfo := struct {
		Args []interface{}
	}{
		Args: args,
	}
	mock.lockInfo.Lock()
	mock.calls.Info = append(mock.calls.Info, callInfo)
	mock.lockInfo.Unlock()
	mock.InfoFunc(args...)
}

// InfoCalls gets all the calls that were made to Info.
// Check the length with:
//
//	len(mockedLog.InfoCalls())
func (mock *LogMock) InfoCalls() []struct {
	Args []interface{}
} {
	var calls []struct {
		Args []interface{}
	}
	mock.lockInfo.RLock()
	calls = mock.calls.Info
	mock.lockInfo.RUnlock()
	return calls
}

// Infof calls InfofFunc.
func (mock *LogMock) Infof(format string, args ...interface{}) {
	if mock.InfofFunc == nil {
		panic("LogMock.InfofFunc: method is nil but Log.Infof was just called")
	}
	callInfo := struct {
		Format string
		Args   []interface{}
	}{
		Format: format,
		Args:   args,
	}
	mock.lockInfof.Lock()
	mock.calls.Infof = append(mock.calls.Infof, callInfo)
	mock.lockInfof.Unlock()
	mock.InfofFunc(format, args...)
}

// InfofCalls gets all the calls that were made to Infof.
// Check the length with:
//
//	len(mockedLog.InfofCalls())
func (mock *LogMock) InfofCalls() []struct {
	Format string
	Args   []interface{}
} {
	var calls []struct {
		Format string
		Args   []interface{}
	}
	mock.lockInfof.RLock()
	calls = mock.calls.Infof
	mock.lockInfof.RUnlock()
	return calls
}

// Panic calls PanicFunc.
func (mock *LogMock) Panic(args ...interface{}) {
	if mock.PanicFunc == nil {
		panic("LogMock.PanicFunc: method is nil but Log.Panic was just called")
	}
	callInfo := struct {
		Args []interface{}
	}{
		Args: args,
	}
	mock.lockPanic.Lock()
	mock.calls.Panic = append(mock.calls.Panic, callInfo)
	mock.lockPanic.Unlock()
	mock.PanicFunc(args...)
}

// PanicCalls gets all the calls that were made to Panic.
// Check the length with:
//
//	len(mockedLog.PanicCalls())
func (mock *LogMock) PanicCalls() []struct {
	Args []interface{}
} {
	var calls []struct {
		Args []interface{}
	}
	mock.lockPanic.RLock()
	calls = mock.calls.Panic
	mock.lockPanic.RUnlock()
	return calls
}

// Panicf calls PanicfFunc.
func (mock *LogMock) Panicf(format string, args ...interface{}) {
	if mock.PanicfFunc == nil {
		panic("LogMock.PanicfFunc: method is nil but Log.Panicf was just called")
	}
	callInfo := struct {
		Format string
		Args   []interface{}
	}{
		Format: format,
		Args:   args,
	}
	mock.lockPanicf.Lock()
	mock.calls.Panicf = append(mock.calls.Panicf, callInfo)
	mock.lockPanicf.Unlock()
	mock.PanicfFunc(format, args...)
}

// PanicfCalls gets all the calls that were made to Panicf.
// Check the length with:
//
//	len(mockedLog.PanicfCalls())
func (mock *LogMock) PanicfCalls() []struct {
	Format string
	Args   []interface{}
} {
	var calls []struct {
		Format string
		Args   []interface{}
	}
	mock.lockPanicf.RLock()
	calls = mock.calls.Panicf
	mock.lockPanicf.RUnlock()
	return calls
}

// Print calls PrintFunc.
func (mock *LogMock) Print(args ...interface{}) {
	if mock.PrintFunc == nil {
		panic("LogMock.PrintFunc: method is nil but Log.Print was just called")
	}
	callInfo := struct {
		Args []interface{}
	}{
		Args: args,
	}
	mock.lockPrint.Lock()
	mock.calls.Print = append(mock.calls.Print, callInfo)
	mock.lockPrint.Unlock()
	mock.PrintFunc(args...)
}

// PrintCalls gets all the calls that were made to Print.
// Check the length with:
//
//	len(mockedLog.PrintCalls())
func (mock *LogMock) PrintCalls() []struct {
	Args []interface{}
} {
	var calls []struct {
		Args []interface{}
	}
	mock.lockPrint.RLock()
	calls = mock.calls.Print
	mock.lockPrint.RUnlock()
	return calls
}

// Printf calls PrintfFunc.
func (mock *LogMock) Printf(format string, args ...interface{}) {
	if mock.PrintfFunc == nil {
		panic("LogMock.PrintfFunc: method is nil but Log.Printf was just called")
	}
	callInfo := struct {
		Format string
		Args   []interface{}
	}{
		Format: format,
		Args:   args,
	}
	mock.lockPrintf.Lock()
	mock.calls.Printf = append(mock.calls.Printf, callInfo)
	mock.lockPrintf.Unlock()
	mock.PrintfFunc(format, args...)
}

// PrintfCalls gets all the calls that were made to Printf.
// Check the length with:
//
//	len(mockedLog.PrintfCalls())
func (mock *LogMock) PrintfCalls() []struct {
	Format string
	Args   []interface{}
} {
	var calls []struct {
		Format string
		Args   []interface{}
	}
	mock.lockPrintf.RLock()
	calls = mock.calls.Printf
	mock.lockPrintf.RUnlock()
	return calls
}

// Warn calls WarnFunc.
func (mock *LogMock) Warn(args ...interface{}) {
	if mock.WarnFunc == nil {
		panic("LogMock.WarnFunc: method is nil but Log.Warn was just called")
	}
	callInfo := struct {
		Args []interface{}
	}{
		Args: args,
	}
	mock.lockWarn.Lock()
	mock.calls.Warn = append(mock.calls.Warn, callInfo)
	mock.lockWarn.Unlock()
	mock.WarnFunc(args...)
}

// WarnCalls gets all the calls that were made to Warn.
// Check the length with:
//
//	len(mockedLog.WarnCalls())
func (mock *LogMock) WarnCalls() []struct {
	Args []interface{}
} {
	var calls []struct {
		Args []interface{}
	}
	mock.lockWarn.RLock()
	calls = mock.calls.Warn
	mock.lockWarn.RUnlock()
	return calls
}

// Warnf calls WarnfFunc.
func (mock *LogMock) Warnf(format string, args ...interface{}) {
	if mock.WarnfFunc == nil {
		panic("LogMock.WarnfFunc: method is nil but Log.Warnf was just called")
	}
	callInfo := struct {
		Format string
		Args   []interface{}
	}{
		Format: format,
		Args:   args,
	}
	mock.lockWarnf.Lock()
	mock.calls.Warnf = append(mock.calls.Warnf, callInfo)
	mock.lockWarnf.Unlock()
	mock.WarnfFunc(format, args...)
}

// WarnfCalls gets all the calls that were made to Warnf.
// Check the length with:
//
//	len(mockedLog.WarnfCalls())
func (mock *LogMock) WarnfCalls() []struct {
	Format string
	Args   []interface{}
} {
	var calls []struct {
		Format string
		Args   []interface{}
	}
	mock.lockWarnf.RLock()
	calls = mock.calls.Warnf
	mock.lockWarnf.RUnlock()
	return calls
}

// Ensure, that RepositoryMock does implement rest.Repository.
// If this is not the case, regenerate this file with moq.
var _ rest.Repository = &RepositoryMock{}

// RepositoryMock is a mock implementation of rest.Repository.
//
//	func TestSomethingThatUsesRepository(t *testing.T) {
//
//		// make and configure a mocked rest.Repository
//		mockedRepository := &RepositoryMock{
//			PersistFunc: func(ctxt context.Context, logger rest.Log, resources []rest.Resource) []error {
//				panic("mock out the Persist method")
//			},
//			RemoveFunc: func(ctxt context.Context, logger rest.Log, resources []rest.Resource) []error {
//				panic("mock out the Remove method")
//			},
//		}
//
//		// use mockedRepository in code that requires rest.Repository
//		// and then make assertions.
//
//	}
type RepositoryMock struct {
	// PersistFunc mocks the Persist method.
	PersistFunc func(ctxt context.Context, logger rest.Log, resources []rest.Resource) []error

	// RemoveFunc mocks the Remove method.
	RemoveFunc func(ctxt context.Context, logger rest.Log, resources []rest.Resource) []error

	// calls tracks calls to the methods.
	calls struct {
		// Persist holds details about calls to the Persist method.
		Persist []struct {
			// Ctxt is the ctxt argument value.
			Ctxt context.Context
			// Logger is the logger argument value.
			Logger rest.Log
			// Resources is the resources argument value.
			Resources []rest.Resource
		}
		// Remove holds details about calls to the Remove method.
		Remove []struct {
			// Ctxt is the ctxt argument value.
			Ctxt context.Context
			// Logger is the logger argument value.
			Logger rest.Log
			// Resources is the resources argument value.
			Resources []rest.Resource
		}
	}
	lockPersist sync.RWMutex
	lockRemove  sync.RWMutex
}

// Persist calls PersistFunc.
func (mock *RepositoryMock) Persist(ctxt context.Context, logger rest.Log, resources []rest.Resource) []error {
	if mock.PersistFunc == nil {
		panic("RepositoryMock.PersistFunc: method is nil but Repository.Persist was just called")
	}
	callInfo := struct {
		Ctxt      context.Context
		Logger    rest.Log
		Resources []rest.Resource
	}{
		Ctxt:      ctxt,
		Logger:    logger,
		Resources: resources,
	}
	mock.lockPersist.Lock()
	mock.calls.Persist = append(mock.calls.Persist, callInfo)
	mock.lockPersist.Unlock()
	return mock.PersistFunc(ctxt, logger, resources)
}

// PersistCalls gets all the calls that were made to Persist.
// Check the length with:
//
//	len(mockedRepository.PersistCalls())
func (mock *RepositoryMock) PersistCalls() []struct {
	Ctxt      context.Context
	Logger    rest.Log
	Resources []rest.Resource
} {
	var calls []struct {
		Ctxt      context.Context
		Logger    rest.Log
		Resources []rest.Resource
	}
	mock.lockPersist.RLock()
	calls = mock.calls.Persist
	mock.lockPersist.RUnlock()
	return calls
}

// Remove calls RemoveFunc.
func (mock *RepositoryMock) Remove(ctxt context.Context, logger rest.Log, resources []rest.Resource) []error {
	if mock.RemoveFunc == nil {
		panic("RepositoryMock.RemoveFunc: method is nil but Repository.Remove was just called")
	}
	callInfo := struct {
		Ctxt      context.Context
		Logger    rest.Log
		Resources []rest.Resource
	}{
		Ctxt:      ctxt,
		Logger:    logger,
		Resources: resources,
	}
	mock.lockRemove.Lock()
	mock.calls.Remove = append(mock.calls.Remove, callInfo)
	mock.lockRemove.Unlock()
	return mock.RemoveFunc(ctxt, logger, resources)
}

// RemoveCalls gets all the calls that were made to Remove.
// Check the length with:
//
//	len(mockedRepository.RemoveCalls())
func (mock *RepositoryMock) RemoveCalls() []struct {
	Ctxt      context.Context
	Logger    rest.Log
	Resources []rest.Resource
} {
	var calls []struct {
		Ctxt      context.Context
		Logger    rest.Log
		Resources []rest.Resource
	}
	mock.lockRemove.RLock()
	calls = mock.calls.Remove
	mock.lockRemove.RUnlock()
	return calls
}

// Ensure, that ProjectionMock does implement rest.Projection.
// If this is not the case, regenerate this file with moq.
var _ rest.Projection = &ProjectionMock{}

// ProjectionMock is a mock implementation of rest.Projection.
//
//	func TestSomethingThatUsesProjection(t *testing.T) {
//
//		// make and configure a mocked rest.Projection
//		mockedProjection := &ProjectionMock{
//			GetByKeyFunc: func(ctxt context.Context, identifiers map[string]interface{}) (rest.Resource, error) {
//				panic("mock out the GetByKey method")
//			},
//			GetByPropertiesFunc: func(ctxt context.Context, identifiers map[string]interface{}) ([]rest.Entity, error) {
//				panic("mock out the GetByProperties method")
//			},
//			GetByURIFunc: func(ctxt context.Context, logger rest.Log, uri string) (rest.Resource, error) {
//				panic("mock out the GetByURI method")
//			},
//			GetListFunc: func(ctx context.Context, page int, limit int, query string, sortOptions map[string]string, filterOptions map[string]interface{}) ([]rest.Resource, int64, error) {
//				panic("mock out the GetList method")
//			},
//		}
//
//		// use mockedProjection in code that requires rest.Projection
//		// and then make assertions.
//
//	}
type ProjectionMock struct {
	// GetByKeyFunc mocks the GetByKey method.
	GetByKeyFunc func(ctxt context.Context, identifiers map[string]interface{}) (rest.Resource, error)

	// GetByPropertiesFunc mocks the GetByProperties method.
	GetByPropertiesFunc func(ctxt context.Context, identifiers map[string]interface{}) ([]rest.Entity, error)

	// GetByURIFunc mocks the GetByURI method.
	GetByURIFunc func(ctxt context.Context, logger rest.Log, uri string) (rest.Resource, error)

	// GetListFunc mocks the GetList method.
	GetListFunc func(ctx context.Context, page int, limit int, query string, sortOptions map[string]string, filterOptions map[string]interface{}) ([]rest.Resource, int64, error)

	// calls tracks calls to the methods.
	calls struct {
		// GetByKey holds details about calls to the GetByKey method.
		GetByKey []struct {
			// Ctxt is the ctxt argument value.
			Ctxt context.Context
			// Identifiers is the identifiers argument value.
			Identifiers map[string]interface{}
		}
		// GetByProperties holds details about calls to the GetByProperties method.
		GetByProperties []struct {
			// Ctxt is the ctxt argument value.
			Ctxt context.Context
			// Identifiers is the identifiers argument value.
			Identifiers map[string]interface{}
		}
		// GetByURI holds details about calls to the GetByURI method.
		GetByURI []struct {
			// Ctxt is the ctxt argument value.
			Ctxt context.Context
			// Logger is the logger argument value.
			Logger rest.Log
			// URI is the uri argument value.
			URI string
		}
		// GetList holds details about calls to the GetList method.
		GetList []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Page is the page argument value.
			Page int
			// Limit is the limit argument value.
			Limit int
			// Query is the query argument value.
			Query string
			// SortOptions is the sortOptions argument value.
			SortOptions map[string]string
			// FilterOptions is the filterOptions argument value.
			FilterOptions map[string]interface{}
		}
	}
	lockGetByKey        sync.RWMutex
	lockGetByProperties sync.RWMutex
	lockGetByURI        sync.RWMutex
	lockGetList         sync.RWMutex
}

// GetByKey calls GetByKeyFunc.
func (mock *ProjectionMock) GetByKey(ctxt context.Context, identifiers map[string]interface{}) (rest.Resource, error) {
	if mock.GetByKeyFunc == nil {
		panic("ProjectionMock.GetByKeyFunc: method is nil but Projection.GetByKey was just called")
	}
	callInfo := struct {
		Ctxt        context.Context
		Identifiers map[string]interface{}
	}{
		Ctxt:        ctxt,
		Identifiers: identifiers,
	}
	mock.lockGetByKey.Lock()
	mock.calls.GetByKey = append(mock.calls.GetByKey, callInfo)
	mock.lockGetByKey.Unlock()
	return mock.GetByKeyFunc(ctxt, identifiers)
}

// GetByKeyCalls gets all the calls that were made to GetByKey.
// Check the length with:
//
//	len(mockedProjection.GetByKeyCalls())
func (mock *ProjectionMock) GetByKeyCalls() []struct {
	Ctxt        context.Context
	Identifiers map[string]interface{}
} {
	var calls []struct {
		Ctxt        context.Context
		Identifiers map[string]interface{}
	}
	mock.lockGetByKey.RLock()
	calls = mock.calls.GetByKey
	mock.lockGetByKey.RUnlock()
	return calls
}

// GetByProperties calls GetByPropertiesFunc.
func (mock *ProjectionMock) GetByProperties(ctxt context.Context, identifiers map[string]interface{}) ([]rest.Entity, error) {
	if mock.GetByPropertiesFunc == nil {
		panic("ProjectionMock.GetByPropertiesFunc: method is nil but Projection.GetByProperties was just called")
	}
	callInfo := struct {
		Ctxt        context.Context
		Identifiers map[string]interface{}
	}{
		Ctxt:        ctxt,
		Identifiers: identifiers,
	}
	mock.lockGetByProperties.Lock()
	mock.calls.GetByProperties = append(mock.calls.GetByProperties, callInfo)
	mock.lockGetByProperties.Unlock()
	return mock.GetByPropertiesFunc(ctxt, identifiers)
}

// GetByPropertiesCalls gets all the calls that were made to GetByProperties.
// Check the length with:
//
//	len(mockedProjection.GetByPropertiesCalls())
func (mock *ProjectionMock) GetByPropertiesCalls() []struct {
	Ctxt        context.Context
	Identifiers map[string]interface{}
} {
	var calls []struct {
		Ctxt        context.Context
		Identifiers map[string]interface{}
	}
	mock.lockGetByProperties.RLock()
	calls = mock.calls.GetByProperties
	mock.lockGetByProperties.RUnlock()
	return calls
}

// GetByURI calls GetByURIFunc.
func (mock *ProjectionMock) GetByURI(ctxt context.Context, logger rest.Log, uri string) (rest.Resource, error) {
	if mock.GetByURIFunc == nil {
		panic("ProjectionMock.GetByURIFunc: method is nil but Projection.GetByURI was just called")
	}
	callInfo := struct {
		Ctxt   context.Context
		Logger rest.Log
		URI    string
	}{
		Ctxt:   ctxt,
		Logger: logger,
		URI:    uri,
	}
	mock.lockGetByURI.Lock()
	mock.calls.GetByURI = append(mock.calls.GetByURI, callInfo)
	mock.lockGetByURI.Unlock()
	return mock.GetByURIFunc(ctxt, logger, uri)
}

// GetByURICalls gets all the calls that were made to GetByURI.
// Check the length with:
//
//	len(mockedProjection.GetByURICalls())
func (mock *ProjectionMock) GetByURICalls() []struct {
	Ctxt   context.Context
	Logger rest.Log
	URI    string
} {
	var calls []struct {
		Ctxt   context.Context
		Logger rest.Log
		URI    string
	}
	mock.lockGetByURI.RLock()
	calls = mock.calls.GetByURI
	mock.lockGetByURI.RUnlock()
	return calls
}

// GetList calls GetListFunc.
func (mock *ProjectionMock) GetList(ctx context.Context, page int, limit int, query string, sortOptions map[string]string, filterOptions map[string]interface{}) ([]rest.Resource, int64, error) {
	if mock.GetListFunc == nil {
		panic("ProjectionMock.GetListFunc: method is nil but Projection.GetList was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		Page          int
		Limit         int
		Query         string
		SortOptions   map[string]string
		FilterOptions map[string]interface{}
	}{
		Ctx:           ctx,
		Page:          page,
		Limit:         limit,
		Query:         query,
		SortOptions:   sortOptions,
		FilterOptions: filterOptions,
	}
	mock.lockGetList.Lock()
	mock.calls.GetList = append(mock.calls.GetList, callInfo)
	mock.lockGetList.Unlock()
	return mock.GetListFunc(ctx, page, limit, query, sortOptions, filterOptions)
}

// GetListCalls gets all the calls that were made to GetList.
// Check the length with:
//
//	len(mockedProjection.GetListCalls())
func (mock *ProjectionMock) GetListCalls() []struct {
	Ctx           context.Context
	Page          int
	Limit         int
	Query         string
	SortOptions   map[string]string
	FilterOptions map[string]interface{}
} {
	var calls []struct {
		Ctx           context.Context
		Page          int
		Limit         int
		Query         string
		SortOptions   map[string]string
		FilterOptions map[string]interface{}
	}
	mock.lockGetList.RLock()
	calls = mock.calls.GetList
	mock.lockGetList.RUnlock()
	return calls
}
