// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package model_test

import (
	"context"
	"github.com/ompluscator/dynamic-struct"
	"github.com/wepala/weos/model"
	"sync"
)

// Ensure, that EndToEndProjectionMock does implement model.EndToEndProjection.
// If this is not the case, regenerate this file with moq.
var _ model.EndToEndProjection = &EndToEndProjectionMock{}

// EndToEndProjectionMock is a mock implementation of model.EndToEndProjection.
//
//     func TestSomethingThatUsesEndToEndProjection(t *testing.T) {
//
//         // make and configure a mocked model.EndToEndProjection
//         mockedEndToEndProjection := &EndToEndProjectionMock{
//             GetByEntityIDFunc: func(ctxt context.Context, entityFactory model.EntityFactory, id string) (map[string]interface{}, error) {
// 	               panic("mock out the GetByEntityID method")
//             },
//             GetByKeyFunc: func(ctxt context.Context, entityFactory model.EntityFactory, identifiers map[string]interface{}) (map[string]interface{}, error) {
// 	               panic("mock out the GetByKey method")
//             },
//             GetContentEntitiesFunc: func(ctx context.Context, entityFactory model.EntityFactory, page int, limit int, query string, sortOptions map[string]string, filterOptions map[string]interface{}) ([]map[string]interface{}, int64, error) {
// 	               panic("mock out the GetContentEntities method")
//             },
//             GetContentEntityFunc: func(ctx context.Context, entityFactory model.EntityFactory, weosID string) (*model.ContentEntity, error) {
// 	               panic("mock out the GetContentEntity method")
//             },
//             GetEventHandlerFunc: func() model.EventHandler {
// 	               panic("mock out the GetEventHandler method")
//             },
//             MigrateFunc: func(ctx context.Context, builders map[string]dynamicstruct.Builder) error {
// 	               panic("mock out the Migrate method")
//             },
//         }
//
//         // use mockedEndToEndProjection in code that requires model.EndToEndProjection
//         // and then make assertions.
//
//     }
type EndToEndProjectionMock struct {
	// GetByEntityIDFunc mocks the GetByEntityID method.
	GetByEntityIDFunc func(ctxt context.Context, entityFactory model.EntityFactory, id string) (map[string]interface{}, error)

	// GetByKeyFunc mocks the GetByKey method.
	GetByKeyFunc func(ctxt context.Context, entityFactory model.EntityFactory, identifiers map[string]interface{}) (map[string]interface{}, error)

	// GetContentEntitiesFunc mocks the GetContentEntities method.
	GetContentEntitiesFunc func(ctx context.Context, entityFactory model.EntityFactory, page int, limit int, query string, sortOptions map[string]string, filterOptions map[string]interface{}) ([]map[string]interface{}, int64, error)

	// GetContentEntityFunc mocks the GetContentEntity method.
	GetContentEntityFunc func(ctx context.Context, entityFactory model.EntityFactory, weosID string) (*model.ContentEntity, error)

	// GetEventHandlerFunc mocks the GetEventHandler method.
	GetEventHandlerFunc func() model.EventHandler

	// MigrateFunc mocks the Migrate method.
	MigrateFunc func(ctx context.Context, builders map[string]dynamicstruct.Builder) error

	// calls tracks calls to the methods.
	calls struct {
		// GetByEntityID holds details about calls to the GetByEntityID method.
		GetByEntityID []struct {
			// Ctxt is the ctxt argument value.
			Ctxt context.Context
			// EntityFactory is the entityFactory argument value.
			EntityFactory model.EntityFactory
			// ID is the id argument value.
			ID string
		}
		// GetByKey holds details about calls to the GetByKey method.
		GetByKey []struct {
			// Ctxt is the ctxt argument value.
			Ctxt context.Context
			// EntityFactory is the entityFactory argument value.
			EntityFactory model.EntityFactory
			// Identifiers is the identifiers argument value.
			Identifiers map[string]interface{}
		}
		// GetContentEntities holds details about calls to the GetContentEntities method.
		GetContentEntities []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// EntityFactory is the entityFactory argument value.
			EntityFactory model.EntityFactory
			// Page is the page argument value.
			Page int
			// Limit is the limit argument value.
			Limit int
			// Query is the query argument value.
			Query string
			// SortOptions is the sortOptions argument value.
			SortOptions map[string]string
			// FilterOptions is the filterOptions argument value.
			FilterOptions map[string]interface{}
		}
		// GetContentEntity holds details about calls to the GetContentEntity method.
		GetContentEntity []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// EntityFactory is the entityFactory argument value.
			EntityFactory model.EntityFactory
			// WeosID is the weosID argument value.
			WeosID string
		}
		// GetEventHandler holds details about calls to the GetEventHandler method.
		GetEventHandler []struct {
		}
		// Migrate holds details about calls to the Migrate method.
		Migrate []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Builders is the builders argument value.
			Builders map[string]dynamicstruct.Builder
		}
	}
	lockGetByEntityID      sync.RWMutex
	lockGetByKey           sync.RWMutex
	lockGetContentEntities sync.RWMutex
	lockGetContentEntity   sync.RWMutex
	lockGetEventHandler    sync.RWMutex
	lockMigrate            sync.RWMutex
}

// GetByEntityID calls GetByEntityIDFunc.
func (mock *EndToEndProjectionMock) GetByEntityID(ctxt context.Context, entityFactory model.EntityFactory, id string) (map[string]interface{}, error) {
	if mock.GetByEntityIDFunc == nil {
		panic("EndToEndProjectionMock.GetByEntityIDFunc: method is nil but EndToEndProjection.GetByEntityID was just called")
	}
	callInfo := struct {
		Ctxt          context.Context
		EntityFactory model.EntityFactory
		ID            string
	}{
		Ctxt:          ctxt,
		EntityFactory: entityFactory,
		ID:            id,
	}
	mock.lockGetByEntityID.Lock()
	mock.calls.GetByEntityID = append(mock.calls.GetByEntityID, callInfo)
	mock.lockGetByEntityID.Unlock()
	return mock.GetByEntityIDFunc(ctxt, entityFactory, id)
}

// GetByEntityIDCalls gets all the calls that were made to GetByEntityID.
// Check the length with:
//     len(mockedEndToEndProjection.GetByEntityIDCalls())
func (mock *EndToEndProjectionMock) GetByEntityIDCalls() []struct {
	Ctxt          context.Context
	EntityFactory model.EntityFactory
	ID            string
} {
	var calls []struct {
		Ctxt          context.Context
		EntityFactory model.EntityFactory
		ID            string
	}
	mock.lockGetByEntityID.RLock()
	calls = mock.calls.GetByEntityID
	mock.lockGetByEntityID.RUnlock()
	return calls
}

// GetByKey calls GetByKeyFunc.
func (mock *EndToEndProjectionMock) GetByKey(ctxt context.Context, entityFactory model.EntityFactory, identifiers map[string]interface{}) (map[string]interface{}, error) {
	if mock.GetByKeyFunc == nil {
		panic("EndToEndProjectionMock.GetByKeyFunc: method is nil but EndToEndProjection.GetByKey was just called")
	}
	callInfo := struct {
		Ctxt          context.Context
		EntityFactory model.EntityFactory
		Identifiers   map[string]interface{}
	}{
		Ctxt:          ctxt,
		EntityFactory: entityFactory,
		Identifiers:   identifiers,
	}
	mock.lockGetByKey.Lock()
	mock.calls.GetByKey = append(mock.calls.GetByKey, callInfo)
	mock.lockGetByKey.Unlock()
	return mock.GetByKeyFunc(ctxt, entityFactory, identifiers)
}

// GetByKeyCalls gets all the calls that were made to GetByKey.
// Check the length with:
//     len(mockedEndToEndProjection.GetByKeyCalls())
func (mock *EndToEndProjectionMock) GetByKeyCalls() []struct {
	Ctxt          context.Context
	EntityFactory model.EntityFactory
	Identifiers   map[string]interface{}
} {
	var calls []struct {
		Ctxt          context.Context
		EntityFactory model.EntityFactory
		Identifiers   map[string]interface{}
	}
	mock.lockGetByKey.RLock()
	calls = mock.calls.GetByKey
	mock.lockGetByKey.RUnlock()
	return calls
}

// GetContentEntities calls GetContentEntitiesFunc.
func (mock *EndToEndProjectionMock) GetContentEntities(ctx context.Context, entityFactory model.EntityFactory, page int, limit int, query string, sortOptions map[string]string, filterOptions map[string]interface{}) ([]map[string]interface{}, int64, error) {
	if mock.GetContentEntitiesFunc == nil {
		panic("EndToEndProjectionMock.GetContentEntitiesFunc: method is nil but EndToEndProjection.GetContentEntities was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		EntityFactory model.EntityFactory
		Page          int
		Limit         int
		Query         string
		SortOptions   map[string]string
		FilterOptions map[string]interface{}
	}{
		Ctx:           ctx,
		EntityFactory: entityFactory,
		Page:          page,
		Limit:         limit,
		Query:         query,
		SortOptions:   sortOptions,
		FilterOptions: filterOptions,
	}
	mock.lockGetContentEntities.Lock()
	mock.calls.GetContentEntities = append(mock.calls.GetContentEntities, callInfo)
	mock.lockGetContentEntities.Unlock()
	return mock.GetContentEntitiesFunc(ctx, entityFactory, page, limit, query, sortOptions, filterOptions)
}

// GetContentEntitiesCalls gets all the calls that were made to GetContentEntities.
// Check the length with:
//     len(mockedEndToEndProjection.GetContentEntitiesCalls())
func (mock *EndToEndProjectionMock) GetContentEntitiesCalls() []struct {
	Ctx           context.Context
	EntityFactory model.EntityFactory
	Page          int
	Limit         int
	Query         string
	SortOptions   map[string]string
	FilterOptions map[string]interface{}
} {
	var calls []struct {
		Ctx           context.Context
		EntityFactory model.EntityFactory
		Page          int
		Limit         int
		Query         string
		SortOptions   map[string]string
		FilterOptions map[string]interface{}
	}
	mock.lockGetContentEntities.RLock()
	calls = mock.calls.GetContentEntities
	mock.lockGetContentEntities.RUnlock()
	return calls
}

// GetContentEntity calls GetContentEntityFunc.
func (mock *EndToEndProjectionMock) GetContentEntity(ctx context.Context, entityFactory model.EntityFactory, weosID string) (*model.ContentEntity, error) {
	if mock.GetContentEntityFunc == nil {
		panic("EndToEndProjectionMock.GetContentEntityFunc: method is nil but EndToEndProjection.GetContentEntity was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		EntityFactory model.EntityFactory
		WeosID        string
	}{
		Ctx:           ctx,
		EntityFactory: entityFactory,
		WeosID:        weosID,
	}
	mock.lockGetContentEntity.Lock()
	mock.calls.GetContentEntity = append(mock.calls.GetContentEntity, callInfo)
	mock.lockGetContentEntity.Unlock()
	return mock.GetContentEntityFunc(ctx, entityFactory, weosID)
}

// GetContentEntityCalls gets all the calls that were made to GetContentEntity.
// Check the length with:
//     len(mockedEndToEndProjection.GetContentEntityCalls())
func (mock *EndToEndProjectionMock) GetContentEntityCalls() []struct {
	Ctx           context.Context
	EntityFactory model.EntityFactory
	WeosID        string
} {
	var calls []struct {
		Ctx           context.Context
		EntityFactory model.EntityFactory
		WeosID        string
	}
	mock.lockGetContentEntity.RLock()
	calls = mock.calls.GetContentEntity
	mock.lockGetContentEntity.RUnlock()
	return calls
}

// GetEventHandler calls GetEventHandlerFunc.
func (mock *EndToEndProjectionMock) GetEventHandler() model.EventHandler {
	if mock.GetEventHandlerFunc == nil {
		panic("EndToEndProjectionMock.GetEventHandlerFunc: method is nil but EndToEndProjection.GetEventHandler was just called")
	}
	callInfo := struct {
	}{}
	mock.lockGetEventHandler.Lock()
	mock.calls.GetEventHandler = append(mock.calls.GetEventHandler, callInfo)
	mock.lockGetEventHandler.Unlock()
	return mock.GetEventHandlerFunc()
}

// GetEventHandlerCalls gets all the calls that were made to GetEventHandler.
// Check the length with:
//     len(mockedEndToEndProjection.GetEventHandlerCalls())
func (mock *EndToEndProjectionMock) GetEventHandlerCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockGetEventHandler.RLock()
	calls = mock.calls.GetEventHandler
	mock.lockGetEventHandler.RUnlock()
	return calls
}

// Migrate calls MigrateFunc.
func (mock *EndToEndProjectionMock) Migrate(ctx context.Context, builders map[string]dynamicstruct.Builder) error {
	if mock.MigrateFunc == nil {
		panic("EndToEndProjectionMock.MigrateFunc: method is nil but EndToEndProjection.Migrate was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Builders map[string]dynamicstruct.Builder
	}{
		Ctx:      ctx,
		Builders: builders,
	}
	mock.lockMigrate.Lock()
	mock.calls.Migrate = append(mock.calls.Migrate, callInfo)
	mock.lockMigrate.Unlock()
	return mock.MigrateFunc(ctx, builders)
}

// MigrateCalls gets all the calls that were made to Migrate.
// Check the length with:
//     len(mockedEndToEndProjection.MigrateCalls())
func (mock *EndToEndProjectionMock) MigrateCalls() []struct {
	Ctx      context.Context
	Builders map[string]dynamicstruct.Builder
} {
	var calls []struct {
		Ctx      context.Context
		Builders map[string]dynamicstruct.Builder
	}
	mock.lockMigrate.RLock()
	calls = mock.calls.Migrate
	mock.lockMigrate.RUnlock()
	return calls
}
